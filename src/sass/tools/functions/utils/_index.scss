@use 'sass:list';
@use 'sass:map';
@use 'sass:meta';
@use 'sass:math';
@use 'sass:string';
@use 'sass:selector';
@use 'sass:color';

@use 'forward-tools' as mlu;
@use 'value-converters' as converters;
@use 'range-parsers';
@forward 'value-converters';
@forward 'parse-util';
@forward 'range-parsers' as parse-util-*;

/*
Utilities

Functions for working with utilities.

Styleguide: sass-tools.functions.utils
*/

// parse-util
//
// Parse utility value or name. Return map with passed value components:
// - `value` - pure value or name
// - `mq` - breakpoint or any mediaquery
// ```scss
//parse-util('1su_md') => ('value': '1su', 'mq': 'md')
// ```
//
// $util-val - utility value or name. Type string.
//
// Styleguide: sass-tools.functions.utils.parse_util

@function parse-util($util-val) {
	$divider-pos: if(meta.type-of($util-val) == 'string', string.index($util-val, '_'), false);
	$mq: null;

	@if $divider-pos {
		$mq: string.slice($util-val, $divider-pos + 1);
		$util-val: string.slice($util-val, 1, $divider-pos - 1);
	}

	@return (
		'value': if(
			mlu.str2n($util-val) or mlu.util-prop($util-val),
			$util-val,
			'-' + $util-val
		),
		'mq': $mq,
	);
}

// parse-util-directions
//
// Parse a map or list with directed utility values. If utility name is not passed, then the directions in the values will become the names of the utilities: t - T, x - -X etc. Returns a map with parsed data.
// ```scss
//$M-map: (
//   'b-2gg': -2gg,
//   'y--bar_lg': calc(5vw - 1.5rem),
//   'b1su': 1su,
//   'xy-auto_all': auto,
//);
//
//@debug mlu.parse-util-directions($M-map, 'M');
///* (
//  'utils-map': (
//    'Mb': ('-2gg': -2gg, '1su': 1su),
//    'My': ('-bar_lg': calc(5vw - 1.5rem)),
//    'M': ('auto_all': auto)
//  )
//  'props': ('margin-bottom', 'margin', 'margin'),
//  'directions': ('b', 'y', 'xy'),
//) */
// ```
// or with list
// ```scss
//@debug mlu.parse-util-directions(('y23', 'r2r', 'x5gg', 'r32su'), 'P');
///* (
//  'utils-map': (
//    'Py': '23',
//    'Pr': ('2r', '32su'),
//    'Px': '5gg'
//  )
//  'props': ('padding', 'padding-right', 'padding'),
//  'directions': ('y', 'r', 'x'),
//) */
// ```
//
// $values - `map` or `list` with values.
// $name = null - directed utility name.
//
// Styleguide: sass-tools.functions.utils.parse_util_dir

@function parse-util-directions($values, $name: null) {
	$utils-map: ();
	$util-directions: ();
	$directed-props: ();

	$append-item-val: if(
		meta.type-of($values) == 'map',
		meta.get-function('merge', false, map),
		meta.get-function('append', false, list)
	);

	@each $key, $value in $values {
		@if meta.type-of($key) != 'string' {
			@error 'Invalid key format `#{$key}` for `#{$name}` in map of values';
		}

		$dir: string.slice($key, 1, 1);
		$dir-val: map.get(mlu.$main-directions, $dir);
		$util-prop: mlu.util-prop($name);
		$util-name: '';

		$utils-map-item-val: -cut-map-item-val($key, $value, 2);

		@if $dir-val {
			@if $name {
				$util-name: $name + $dir;
				$util-prop: $util-prop + '-' + $dir-val;
			} @else {
				$util-name: string.to-upper-case($dir);
				$util-prop: $dir-val;
			}
		} @else if $dir == 'x' and string.slice($key, 2, 2) == 'y' {
			$utils-map-item-val: -cut-map-item-val($key, $value, 3);

			@if $name {
				$util-name: $name;
				$dir: 'xy';
			} @else {
				$util-name: '-Xy';
				$dir: 'all';
			}
		} @else if $dir == 'x' or $dir == 'y' {
			@if $name {
				$util-name: $name + $dir;
			} @else {
				$util-name: '-' + string.to-upper-case($dir);
			}
		} @else {
			@error 'Invalid direction `#{$dir}` for `#{$name}` in map of values';
		}

		@if not map.has-key($utils-map, $util-name) {
			$utils-map: map.merge($utils-map, ($util-name: $utils-map-item-val));
			$util-directions: list.append($util-directions, $dir);
			$directed-props: list.append($directed-props, $util-prop);
		} @else {
			//This will be refactored when Sass nested map functions will be released
			$utils-map: map.merge(
				$utils-map,
				($util-name: meta.call($append-item-val, map.get($utils-map, $util-name), $utils-map-item-val))
			);
		}
	}

	@return (
		'utils-map': $utils-map,
		'props': $directed-props,
		'directions': $util-directions,
	);
}

// Private function that cuts utility value from string with direction

@function -cut-map-item-val($raw-val, $css-val, $val-pos) {
	$util-val: if(
		not mlu.str2n(string.slice($raw-val, $val-pos)),
		string.slice($raw-val, $val-pos + 1),
		string.slice($raw-val, $val-pos)
	);

	@if $css-val {
		@return ($util-val: $css-val);
	}

	@return $util-val;
}

@function convert-util-states($states, $this-util: null, $pre: false) {
	$prefix: '&';
	$suffix: '';

	@if $pre {
		$prefix: '';

		@if string.slice($states, -1) == '.' {
			$states: string.slice($states, 1, -2);
		} @else {
			$suffix: ' ';
		}
	}

	$result: $prefix;
	$or: ', ';

	@each $state in mlu.str-split($states, mlu.$tSOr) {
		@each $item in mlu.str-split($state, mlu.$tSAnd) {
			$converted: '';
			$not: string.slice($item, 1, 1) == mlu.$tSNot;

			@if $not {
				$item: string.slice($item, 2);
			}

			@if map.has-key(mlu.$utils-states, $item) {
				$converted: map.get(mlu.$utils-states, $item);
			} @else if mlu.str-starts($item, mlu.$tSCs) {
				$item-name: string.slice($item, 2);

				@if map.has-key(mlu.$utils-config, 'states', 'custom', $item-name) {
					$converted: map.get(mlu.$utils-config, 'states', 'custom', $item-name);
				} @else {
					@return mlu.error('Undefined custom state: `#{$item}`');
				}
			} @else if mlu.str-starts($item, mlu.$tSCn) {
				$ctx-value: string.slice($item, 2);
				$converted: '.' + mlu.str-escape(
					mlu.$cCtx + util-separated-value($ctx-value)
				);
			} @else if mlu.str-starts($item, mlu.$tSRaw) {
				$converted: string.slice($item, 2);
			} @else if mlu.str-starts($item, mlu.$tSTu) {
				@if not $this-util {
					@return mlu.error('`#{mlu.$tSTu}` cannot be used because $this-util is not passed');
				}

				@if $item == mlu.$tSTucv {
					$converted: mlu.str-escape(mlu.$tSTucv);
				} @else {
					$converted: mlu.check-class($this-util + mlu.str-escape(string.slice($item, 2)));
				}
			} @else if $item == '' {
				$converted: ' ';
			} @else {
				@return mlu.error('Invalid state: `#{$item}`');
			}

			@if $not {
				$converted: ':not(#{$converted})';
			}

			$result: $result + $converted;
		}

		$result:  $result + $suffix + $or + $prefix;
	}

	@return string.slice($result, 1, -(1 + string.length($or) + string.length($prefix)));
}

@function -str-item-index($item, $i, $str) {
	@return string.index($item, $str);
}

@function util-apply-selector($custom-sel, $util-sel-list) {
	@if not $custom-sel {
		@return $util-sel-list;
	}

	$result: ();

	@if not string.index(meta.inspect($custom-sel), mlu.$tSTu) {
		@each $foreign-sel in $custom-sel {
			@each $util-selector in $util-sel-list {
				$util-sel-str: if(
					meta.type-of($util-selector) == 'list',
					meta.inspect($util-selector),
					$util-selector
				);

				$util-simple-sel: -util-simple-selector($util-sel-str);
				$result: list.append(
					$result,
					if(
						$util-simple-sel == $util-sel-str,
						$foreign-sel,
						mlu.str-replace-all($util-sel-str, $util-simple-sel, $foreign-sel)
					),
					comma
				);
			}
		}
	} @else {
		@each $util-selector in $util-sel-list {
			$selector: $custom-sel;
			$complex-sel-list: mlu.str-split($selector, ' ');

			$compound-sel: if(
				list.length($complex-sel-list) > 1,
				mlu.ls-find($complex-sel-list, meta.get-function('-str-item-index'), mlu.$tSTu),
				$selector
			);

			$compound-sel-prefix: list.nth(mlu.str-split($compound-sel, mlu.$tSTu), 1);
			$new-util-compd-sel: null;

			$util-sel-str: if(
				meta.type-of($util-selector) == 'list',
				meta.inspect($util-selector),
				$util-selector
			);

			@if $compound-sel-prefix != '' {
				$util-simple-sel: -util-simple-selector($util-sel-str);
				$new-util-compd-sel: $compound-sel-prefix + string.slice($util-simple-sel, 2);

				$util-sel-str: mlu.str-replace(
					$util-sel-str, $util-simple-sel, $new-util-compd-sel
				);

				$selector: mlu.str-replace(
					$selector, $compound-sel-prefix + mlu.$tSTu, $util-sel-str
				);
			} @else {
				$selector: mlu.str-replace($selector, mlu.$tSTu, $util-sel-str);
			}

			@if string.index($selector, mlu.$tSTu) {
				$selector: mlu.str-replace-all(
					$selector,
					mlu.$tSTu,
					$new-util-compd-sel or -util-simple-selector($util-sel-str)
				);
			}

			$result: list.append($result, $selector, comma);
		}
	}

	@return if(
		list.length($result) > 1,
		$result,
		list.nth($result, 1)
	);
}

@function -util-simple-selector($util-selector) {
	// A bad solution, because a simple selector can be obtained in `mk-state` mixin, but now it seems too difficult to do it. Maybe this will be refactored in future
	$complex-sel: list.nth(selector.parse($util-selector), 1);

	$compound-sel: if(
		list.length($complex-sel) > 1,
		mlu.ls-find($complex-sel, meta.get-function('-str-item-index'), mlu.$tUCm),
		list.nth($complex-sel, 1)
	);

	$simple-sel-list: selector.simple-selectors($compound-sel);

	@return if(
		list.length($simple-sel-list) > 1,
		mlu.ls-find($simple-sel-list, meta.get-function('-str-item-index'), mlu.$tUCm),
		$compound-sel
	);
}

@function util-separated-value($value) {
	@if $value == '' {
		@return '';
	}

	@if mlu.str2n($value) {
		@return mlu.$tUNv + $value;
	}

	$str-value: if(
		meta.type-of($value) == 'string',
		$value,
		$value + ''
	);

	$first-char: string.slice($str-value, 1, 1);

	@if $first-char == '#' {
		@return mlu.$tUHv + $str-value;
	}

	@return if(
		$first-char == mlu.$tURv,
		$str-value,
		mlu.$tUSv + $str-value
	);
}

@function -str-contains-item($item, $i, $str) {
	@return string.index($str, $item);
}

@function parse-abbr($abbr) {
	$abbr-name: $abbr;
	$abbr-value: '';
	$abbr-prefix: '';
	$hash-value-sep: mlu.$tUHv;
	$all-separators: mlu.$abbr-separators;
	$result: ();

	@if string.slice($abbr, 1, 1) == '-' {
		$abbr: string.slice($abbr, 2);
		$abbr-prefix: '-';
	}

	@if mlu.$tUHv == '' {
		$hash-value-sep: '#';
		$all-separators: list.append($all-separators, '#');
	}

	$separator: mlu.ls-find(
		$all-separators, meta.get-function('-str-contains-item'), $abbr
	);

	@if $separator {
		$abbr-parts: mlu.str-split($abbr, $separator, 1);
		$abbr-name: list.nth($abbr-parts, 1);
		$abbr-value: list.nth($abbr-parts, 2);

		@if mlu.$tUNv == '' and $separator == '-' and mlu.str2n($abbr-value) {
			$abbr-value: '-' + $abbr-value;
		} @else if $separator == $hash-value-sep or $separator == mlu.$tURv {
			$abbr-value: $separator + $abbr-value;
		} @else {
			$result: map.set($result, 'separator', $separator);
		}
	} @else {
		@if mlu.$tUNv == '' {
			$number-index: mlu.str-digit-index($abbr);

			@if $number-index {
				$abbr-name: string.slice($abbr, 1, $number-index - 1);
				$abbr-value: string.slice($abbr, $number-index);
			}
		}
	}

	@return map.merge(
		$result,
		(
			'value': $abbr-value,
			'name': $abbr-prefix + $abbr-name,
		)
	);
}

$-util-value-converters: ();

$-fn-name-prefix: 'convert-uv-';
$-fn-prefix-length: string.length($-fn-name-prefix);

@each $key, $value in meta.module-functions(converters) {
	@if string.index($key, $-fn-name-prefix) {
		$-util-value-converters: map.set(
			$-util-value-converters, string.slice($key, $-fn-prefix-length + 1), $value
		);
	}
}

mlu.$utils-config: map.set(
	mlu.$utils-config,
	'value-converters',
	map.merge($-util-value-converters, map.get(mlu.$utils-config, 'value-converters'))
);

$-util-range-parsers: ();

@each $key, $value in meta.module-functions(range-parsers) {
	$suffix-pos: string.index($key, '-range');

	@if $suffix-pos {
		$-util-range-parsers: map.set(
			$-util-range-parsers, string.slice($key, 1, $suffix-pos - 1), $value
		);
	}
}

mlu.$utils-config: map.set(
	mlu.$utils-config,
	'range-parsers',
	map.merge($-util-range-parsers, map.get(mlu.$utils-config, 'range-parsers'))
);

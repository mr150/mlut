@use 'sass:list';
@use 'sass:map';
@use 'sass:meta';
@use 'sass:math';
@use 'sass:string';

@use '../settings' as mlu;
@use 'general' as mgen;
@use 'getters' as mget;

/*
Utilities

Functions for working with utilities.

Styleguide: sass-tools.functions.utils
*/

// parse-util
//
// Parse utility value or name. Return map with passed value components:
// - `value` - pure value or name
// - `mq` - breakpoint or any mediaquery
// ```scss
//parse-util('1su_md') => ('value': '1su', 'mq': 'md')
// ```
//
// $util-val - utility value or name. Type string.
//
// Styleguide: sass-tools.functions.utils.parse_util

$-mq-keywords: list.join(
	map.keys(map.get(mlu.$at-rules-data, 'all-breakpoints')),
	(mlu.$bp-only mlu.$bp-all)
);

@function parse-util($util-val) {
	$divider-pos: if(meta.type-of($util-val) == 'string', string.index($util-val, '_'), false);
	$mq: null;

	@if $divider-pos {
		$mq: string.slice($util-val, $divider-pos + 1);
		$util-val: string.slice($util-val, 1, $divider-pos - 1);
	}

	@return (
		'value': if(
			mgen.str2n($util-val) or mget.util-prop($util-val, 0),
			$util-val,
			'-' + $util-val
		),
		'mq': $mq,
	);
}

@function new-parse-util($raw-value) {
	$raw-value-parts: mgen.str-split($raw-value + '', '_');
	$result: ();
	$at-rules: null;
	$value: null;

	@if list.length($raw-value-parts) > 1 {
		@each $component in $raw-value-parts {
			$component-list: mgen.str-split(mgen.str-trim($component), ' ');
			$component-item: list.nth($component-list, 1);

			$part: list.nth(mgen.str-split(
				list.nth(mgen.str-split($component-item, ','), 1),
				':'
			), 1);
			@if not $at-rules and (
				string.index($part, '@') == 1 or list.index($-mq-keywords, $part)
			) {
				$at-rules: $component-list;
			} @else if (string.index($component, ' ') or $value) and
				map.has-key(mlu.$util-states, $part) {
				$result: map.set($result, 'post-states', $component-list);
			} @else if list.index(
				'^' '/' ':',
				string.slice($component-item, 1, 1)
			) {
				$result: map.set(
					$result,
					if($value, 'post-states', 'pre-states'),
					$component-list
				);
			} @else {
				$value: $component-list;
			}
		}
	} @else {
		$value: $raw-value;
	}

	@if not $value {
		$value: $at-rules;
	} @else if $at-rules {
		$result: map.set($result, 'at-rules', $at-rules);
	}

	$result: map.set($result, 'value', $value);

	@return $result;
}

// parse-util-directions
//
// Parse a map or list with directed utility values. If utility name is not passed, then the directions in the values will become the names of the utilities: t - T, x - -X etc. Returns a map with parsed data.
// ```scss
//$M-map: (
//   'b-2gg': -2gg,
//   'y--bar_lg': calc(5vw - 1.5rem),
//   'b1su': 1su,
//   'xy-auto_all': auto,
//);
//
//@debug mlu.parse-util-directions($M-map, 'M');
///* (
//  'utils-map': (
//    'Mb': ('-2gg': -2gg, '1su': 1su),
//    'My': ('-bar_lg': calc(5vw - 1.5rem)),
//    'M': ('auto_all': auto)
//  )
//  'props': ('margin-bottom', 'margin', 'margin'),
//  'directions': ('b', 'y', 'xy'),
//) */
// ```
// or with list
// ```scss
//@debug mlu.parse-util-directions(('y23', 'r2r', 'x5gg', 'r32su'), 'P');
///* (
//  'utils-map': (
//    'Py': '23',
//    'Pr': ('2r', '32su'),
//    'Px': '5gg'
//  )
//  'props': ('padding', 'padding-right', 'padding'),
//  'directions': ('y', 'r', 'x'),
//) */
// ```
//
// $values - `map` or `list` with values.
// $name = null - directed utility name.
//
// Styleguide: sass-tools.functions.utils.parse_util_dir

@function parse-util-directions($values, $name: null) {
	$utils-map: ();
	$util-directions: ();
	$directed-props: ();

	$append-item-val: if(
		meta.type-of($values) == 'map',
		meta.get-function('merge', false, map),
		meta.get-function('append', false, list)
	);

	@each $key, $value in $values {
		@if meta.type-of($key) != 'string' {
			@error 'Invalid key format `#{$key}` for `#{$name}` in map of values';
		}

		$dir: string.slice($key, 1, 1);
		$dir-val: map.get(mlu.$main-directions, $dir);
		$util-prop: mget.util-prop($name, 0);
		$util-name: '';

		$utils-map-item-val: -cut-map-item-val($key, $value, 2);

		@if $dir-val {
			@if $name {
				$util-name: $name + $dir;
				$util-prop: $util-prop + '-' + $dir-val;
			} @else {
				$util-name: string.to-upper-case($dir);
				$util-prop: $dir-val;
			}
		} @else if $dir == 'x' and string.slice($key, 2, 2) == 'y' {
			$utils-map-item-val: -cut-map-item-val($key, $value, 3);

			@if $name {
				$util-name: $name;
				$dir: 'xy';
			} @else {
				$util-name: '-Xy';
				$dir: 'all';
			}
		} @else if $dir == 'x' or $dir == 'y' {
			@if $name {
				$util-name: $name + $dir;
			} @else {
				$util-name: '-' + string.to-upper-case($dir);
			}
		} @else {
			@error 'Invalid direction `#{$dir}` for `#{$name}` in map of values';
		}

		@if not map.has-key($utils-map, $util-name) {
			$utils-map: map.merge($utils-map, ($util-name: $utils-map-item-val));
			$util-directions: list.append($util-directions, $dir);
			$directed-props: list.append($directed-props, $util-prop);
		} @else {
			//This will be refactored when Sass nested map functions will be released
			$utils-map: map.merge(
				$utils-map,
				($util-name: meta.call($append-item-val, map.get($utils-map, $util-name), $utils-map-item-val))
			);
		}
	}

	@return (
		'utils-map': $utils-map,
		'props': $directed-props,
		'directions': $util-directions,
	);
}

// Private function that cuts utility value from string with direction

@function -cut-map-item-val($raw-val, $css-val, $val-pos) {
	$util-val: if(
		not mgen.str2n(string.slice($raw-val, $val-pos)),
		string.slice($raw-val, $val-pos + 1),
		string.slice($raw-val, $val-pos)
	);

	@if $css-val {
		@return ($util-val: $css-val);
	}

	@return $util-val;
}

// convert-util-value
//
// Determines the type of utility and, depending on type, calls the converter from the `$util-value-converters` map. If the utility type is not recognized, the [default converter](#kssref-sass-tools-functions-utils-value_converters-def) is called. If the `$utils-value-converters` does not contain a converter for this type, the utility value is returned without conversion. Else the result of the converter work is returned.
// ```scss
//@debug mlu.convert-util-value('2r', 'Fz'); // 2rem
//@debug mlu.convert-util-value(100, 'Fw'); // 100
// ```
//
// $util-val - utility value
// $name - utility name
//
// Styleguide: sass-tools.functions.utils.convert_util_value

@function convert-util-value($util-val, $name) {
	$util-type: if(
		map.has-key(mlu.$utils-data, 'registry', $name, 'type'),
		map.get(mlu.$utils-data, 'registry', $name, 'type'),
		''
	);

	@return if(
		map.has-key($util-value-converters, $util-type),
		meta.call(
			map.get($util-value-converters, $util-type),
			$util-val
		),
		$util-val
	);
}

// convert-util-value-default
//
// Default converter for utility value to CSS value. Converts numbers with unit aliases.
// ```scss
//@debug mlu.convert-util-value-default(480); // 480px
//@debug mlu.convert-util-value-default('n'); // none
// ```
//
// $value - utility value.
//
// Styleguide: sass-tools.functions.utils.value_converters.def

@function convert-util-value-default($value) {
	$val-unit: '';
	$val-number: mgen.str2n($value + '');

	@if meta.type-of($value) == 'number' {
		$val-unit: map.get(mlu.$util-units-map, math.unit($value));
	} @else if meta.type-of($value) == 'string' and  $val-number {
		$util-unit: string.slice($value, string.length($val-number + '') + 1);
		$val-unit: map.get(mlu.$util-units-map, $util-unit);
	}

	@if $val-unit != '' {
		// Maybe in the future there will be processing of all CSS units, but so far a number with an unknown unit is returned as a string
		@return if(
			$val-unit,
			$val-number * $val-unit,
			string.unquote($value + '')
		);
	}

	@return convert-util-value-keyword($value);
}

// convert-util-value-unitless
//
// Convert unitless numbers from string to numbers.
// ```scss
//@debug mlu.convert-util-value-unitless('200'); // 200
//@debug mlu.convert-util-value-unitless('a'); // auto
// ```
//
// $value - utility value.
//
// Styleguide: sass-tools.functions.utils.value_converters.unitless

@function convert-util-value-unitless($value) {
	$val-number: mgen.str2n($value);

	@return if(
		$val-number,
		$val-number,
		convert-util-value-keyword($value)
	);
}

// convert-util-value-keyword
//
// Converts aliases to global CSS keywords. If the alias is not found in the `$util-css-keywords`, returns the value without conversion.
// ```scss
//@debug mlu.convert-util-value-keyword('i'); // inherit
//@debug mlu.convert-util-value-keyword('b'); // 'b'
// ```
//
// $value - utility value.
//
// Styleguide: sass-tools.functions.utils.value_converters.kw

@function convert-util-value-keyword($value) {
	@return if(
		map.has-key(mlu.$utils-data, 'css-keywords', $value),
		map.get(mlu.$utils-data, 'css-keywords', $value),
		$value
	);
}

// Utilities value converters
//
// All converters are contained in the `$util-value-converters` map. The keys in this map are the utility types and the values are the conversion functions. As in other settings, you can add additional converters in `$util-value-converters-ext`.
//
// At the end of the work, each function, passes the result to the [global CSS keywords converter](#kssref-sass-tools-functions-utils-value_converters-kw).
//
// Styleguide: sass-tools.functions.utils.value_converters

$util-value-converters: (
	'': meta.get-function('convert-util-value-default'),
	'unitless': meta.get-function('convert-util-value-unitless'),
) !default;

$util-value-converters: map.merge(
	$util-value-converters,
	map.get(mlu.$utils-data, 'value-converters'),
);

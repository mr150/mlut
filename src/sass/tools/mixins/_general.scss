@use "sass:meta";
@use "sass:list";
@use "sass:math";

/*
General

General purpose mixins.

Styleguide: sass-tools.mixins.general
*/

// mlu-bpm
//
// Bpm is breakpoint manager.
// ```scss
// @include mlu-bpm("md") {
//		.inp--common {
//			padding-left: 48px;
//		}
// }
//
// @include mlu-bpm($to: "lg") {
//		.btn--common {
//			margin-left: 48px;
//		}
// }
//
// @include mlu-bpm("sm", "lg") {
//		.btn--common {
//			margin-top: 48px;
//		}
// }
// ```
// Compile into:
// ```css
// @media (min-width: 760px) {
//		.inp--common {
//			padding-left: 48px;
//		}
// }
//
// @media (max-width: 959px) {
//		.btn--common {
//			margin-left: 48px;
//		}
// }
//
// @media (min-width: 520px) and (max-width: 959px) {
//		.btn--common {
//			margin-top: 48px;
//		}
// }
// ```
//
// $from = false - breakpoint. Can be keyword (string) or number. Generate to 'min-width' mediaquery, and `$to` to 'max-width' - 1.
// $to = false - breakpoint. Can be keyword (string) or number. Generate to 'max-width' - 1 mediaquery. Together with `$from` generate to 'min-width and max-width - 1'.
// $opt = false - string with additional media-features to check.
// For example:
// `(orientation: landscape)`,
// `screen and (aspect-ratio: 11/5)`,
// `print`.
// $prop = "width" - property in mediaquery. Property generate like `#{$type}-#{$prop}`,
// where `$type` can be 'min' or 'max'.
// `$type` depends on availability `$from` and `$to`
// @content - CSS relus that will be placed into mediaquery.
//
// Styleguide: sass-tools.mixins.general.bpm

@mixin mlu-bpm($from: false, $to: false, $opt: false, $prop: "width") {
	$type: "min";
	$bp-val: ();

	@if $from and $to {
		$type: "range";
	} @else if $to {
		$type: "max";
	} @else if not $from {
		@error "Breakpoint value must be not null.";
	}

	@each $item in ($from, $to) {
		@if meta.type-of($item) == "string" {
			$bp-val: list.append($bp-val,
			if($item == $to,
			mlu-bp($item) - 1,
			mlu-bp($item)));
		} @else if meta.type-of($item) == "number" and not math.is-unitless($item) {
			$item-to: $item;

			@if math.unit($item) == "em" {
				$item-to: mlu-px2em((($item / 1em) * $mlu-browser-font-size) - 1, $mlu-browser-font-size);
			} @else if math.unit($item) == "rem" {
				$item-to: mlu-px2rem((($item / 1rem) * $mlu-browser-font-size) - 1, $mlu-browser-font-size);
			} @else if math.unit($item) == "px" {
				$item-to: $item - 1;
			}

			$bp-val: list.append($bp-val,
			if($item == $to, $item-to, $item));
		} @else if meta.type-of($item) != "bool" or (meta.type-of($item) == "bool" and $item) {
			@error "Invalid breakpoint type: '#{meta.type-of($item)}' or value: '#{$item}'";
		}
	}

	$opt: if($opt, $opt + " ", "");
	$media-str: "";

	@if $type == "range" {
		$media-str: $opt + "(min-" + $prop + ":" + list.nth($bp-val, 1) + ") and (max-" + $prop + ":" + list.nth($bp-val, 2) + ")";
	} @else {
		$bp-val: list.nth($bp-val, 1);
		$media-str: $opt + "(" + $type + "-" + $prop + ":" + $bp-val + ")";
	}

	@media #{$media-str} {
		@content;
	}
}

// mlu-mCl
//
// Generate clearfix for float layout.
// ```scss
//.block {
//		@include mlu-mCl;
//}
// ```
// CSS
// ```css
//.block:after {
//		display: table;
//		clear: both;
//		content: "";
//}
// ```
//
// Styleguide: sass-tools.mixins.general.mcl

@mixin mlu-mCl {
	&:after {
		display: table;
		clear: both;
		content: "";
	}
}

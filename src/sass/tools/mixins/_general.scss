@use 'sass:meta';
@use 'sass:map';
@use 'sass:list';
@use 'sass:math';
@use 'sass:string';

@use 'forward-tools' as mlu;
@use '../functions/general' as mgen;

/*
General

General purpose mixins.

Styleguide: sass-tools.mixins.general
*/

// bpm
//
// Bpm is breakpoint manager.
// ```scss
// @include bpm('md') {
//		.inp--common {
//			padding-left: 48px;
//		}
// }
//
// @include bpm($to: 'lg') {
//		.btn--common {
//			margin-left: 48px;
//		}
// }
//
// @include bpm('sm', 'lg') {
//		.btn--common {
//			margin-top: 48px;
//		}
// }
// ```
// Compile into:
// ```css
// @media (min-width: 760px) {
//		.inp--common {
//			padding-left: 48px;
//		}
// }
//
// @media (max-width: 959px) {
//		.btn--common {
//			margin-left: 48px;
//		}
// }
//
// @media (min-width: 520px) and (max-width: 959px) {
//		.btn--common {
//			margin-top: 48px;
//		}
// }
// ```
//
// $from = false - breakpoint. Can be keyword (string) or number. Generate to 'min-width' mediaquery, and `$to` to 'max-width' - 1.
// $to = false - breakpoint. Can be keyword (string) or number. Generate to 'max-width' - 1 mediaquery. Together with `$from` generate to 'min-width and max-width - 1'.
// $opt = false - string with additional media-features to check.
// For example:
// `(orientation: landscape)`,
// `screen and (aspect-ratio: 11/5)`,
// `print`.
// $prop = 'width' - property in mediaquery. Property generate like `#{$type}-#{$prop}`,
// where `$type` can be 'min' or 'max'.
// `$type` depends on availability `$from` and `$to`
// @content - CSS relus that will be placed into mediaquery.
//
// Styleguide: sass-tools.mixins.general.bpm

@mixin bpm($from: false, $to: false, $opt: false, $prop: 'width') {
	$type: 'min';
	$bp-val: ();

	@if $from and $to {
		$type: 'range';
	} @else if $to {
		$type: 'max';
	} @else if not $from {
		@error 'Breakpoint value must be not null.';
	}

	@each $item in ($from, $to) {
		@if meta.type-of($item) == 'string' {
			$bp-val: list.append($bp-val,
			if($item == $to,
			mlu.bp($item) - 1,
			mlu.bp($item)));
		} @else if meta.type-of($item) == 'number' and not math.is-unitless($item) {
			$item-to: $item;

			@if math.unit($item) == 'em' {
				$item-to: mlu.px2em((($item / 1em) * mlu.$browser-font-size) - 1, mlu.$browser-font-size);
			} @else if math.unit($item) == 'rem' {
				$item-to: mlu.px2rem((($item / 1rem) * mlu.$browser-font-size) - 1, mlu.$browser-font-size);
			} @else if math.unit($item) == 'px' {
				$item-to: $item - 1;
			}

			$bp-val: list.append($bp-val,
			if($item == $to, $item-to, $item));
		} @else if meta.type-of($item) != 'bool' or (meta.type-of($item) == 'bool' and $item) {
			@error 'Invalid breakpoint type: `#{meta.type-of($item)}` or value: `#{$item}`';
		}
	}

	$opt: if($opt, $opt + ' ', '');
	$media-str: '';

	@if $type == 'range' {
		$media-str: $opt + '(min-' + $prop + ':' + list.nth($bp-val, 1) + ') and (max-' + $prop + ':' + list.nth($bp-val, 2) + ')';
	} @else {
		$bp-val: list.nth($bp-val, 1);
		$media-str: $opt + '(' + $type + '-' + $prop + ':' + $bp-val + ')';
	}

	@media #{$media-str} {
		@content;
	}
}

// cCl
//
// Generate clearfix for float layout.
// ```scss
//.block {
//		@include cCl;
//}
// ```
// CSS
// ```css
//.block:after {
//		display: table;
//		clear: both;
//		content: '';
//}
// ```
//
// Styleguide: sass-tools.mixins.general.-cl

@mixin cCl {
	&:after {
		display: table;
		clear: both;
		content: '';
	}
}

// mk-ar
//
// Generate at-rules from list of abbreviations.
//
// ```scss
//@include mlu.mk-ar('@s', 'D-ig') {
//  .D-ig {
//     display: inline-grid;
//  }
//}
// ```
// CSS
// ```css
//@supports (display: inline-grid) {
//  .D-ig {
//	  display: inline-grid;
//  }
//}
// ```
//
// $at-rules - abbreviations list
// $this-util = null - utility for which the at-rules will be generated
//
// Styleguide: sass-tools.mixins.general.mk_ar

@mixin mk-ar($at-rules, $this-util: null) {
	@each $item in $at-rules {
		$keyword-pos: string.index($item, mlu.$bp-all);

		@if $keyword-pos {
			$at-rules: mgen.remove-nth($at-rules, list.index($at-rules, $item));

			@each $bp in map.keys(mlu.$breakpoints) {
				$at-rules: list.append($at-rules, mgen.str-replace($item, mlu.$bp-all, $bp));
			}
		}
	}

	@each $item in $at-rules {
		$ar-list: mgen.str-split($item, '@');

		@if list.nth($ar-list, 1) == '' {
			$ar-list: mgen.remove-nth($ar-list, 1);
		}

		@include -generate-ar($item, $this-util, $ar-list, 1, list.length($ar-list)) {
			@content;
		}
	}
}

@mixin -generate-ar($at-rules, $this-util, $ar-list, $cur-index, $last-index) {
	$item: list.nth($ar-list, $cur-index);
	$ar-alias: list.nth(mgen.str-split($item, ':'), 1);
	$ar-name: null;
	$converter: null;
	$ar-str: $item;

	@if string.index($at-rules, '@') == 1 or $cur-index > 1 {
		@each $key, $value in mlu.$at-rules-data {
			@if map.get(mlu.$at-rules-data, $key, 'alias') == $ar-alias {
				$ar-name: $key;
				$converter: map.get(mlu.$at-rules-data, $key, 'converter');
				$ar-str: string.slice($item, string.length($ar-alias) + 2);
			}
		}
	} @else {
		$ar-name: 'media';
		$converter: meta.get-function('convert-ar-bp', false, mlu);
	}

	@if not $ar-name {
		@error 'At-rule for alias `#{$ar-alias}` is not defined';
	}

	@#{$ar-name} #{meta.call($converter, $ar-str, $this-util)} {
		@if $cur-index < $last-index {
			@include -generate-ar($at-rules, $this-util, $ar-list, $cur-index + 1, $last-index) {
				@content;
			}
		} @else {
			@content;
		}
	}
}

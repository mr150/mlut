@use 'sass:meta';
@use 'sass:list';
@use 'sass:map';
@use 'sass:math';
@use 'sass:string';

@use '../forward-tools' as ml;
@use 'mk-util' as mu;

@forward 'mk-util';

$-su-rem: ml.px2rem(ml.$su);
$-gtr-sm-rem: ml.px2rem(ml.$gtr-sm);

$-utils-directed: map.get(ml.$utils-cfg, 'directed');

/*
Utilities

Mixins for creating utilities and working with them.

Styleguide: sass-tools.mixins.utils
*/

// bp-all
//
// Generates the CSS rule on breakpoints, adding the name of the breakpoint to the selector, inside the corresponding media query.
//
// ```scss
//@include bp-all('.Bdw1') {
//		border-width: 1px;
//}
// ```
// CSS
// ```css
//.Bdw1 {
//		border-width: 1px;
//}
//
//@media (min-width: 520px) {
//		.Bdw1_sm {
//			border-width: 1px;
//		}
//}
//
//@media (min-width: 760px) {
//		.Bdw1_md {
//			border-width: 1px;
//		}
//}
//
//@media (min-width: 960px) {
//		.Bdw1_lg {
//			border-width: 1px;
//		}
//}
//
//@media (min-width: 1168px) {
//		.Bdw1_xl {
//			border-width: 1px;
//		}
//}
// ```
// You can also use mixin inside the rule. This will work as well as the example above:
// ```scss
//.Bdw1 {
//		@include bp-all() {
//			border-width: 1px;
//		}
//}
// ```
//
// $selector = & - selector of CSS rule. Can be `string` or `&`.
// $xs = 1 - any type flag. If equal to 1, then the rule will first be generated outside of breakpoints(in `xs`).
//
// Styleguide: sass-tools.mixins.utils.bp_all

@mixin bp-all($selector: &, $xs: 1) {
	@if not $selector {
		@error '`$selector` argument must not be null.';
	}

	@at-root {
		@if $xs == 1 {
			#{$selector} {
				@content;
			}
		}

		@each $key, $value in ml.$bp-map {
			@include ml.bpm($key) {
				#{$selector}_#{$key} {
					@content;
				}
			}
		}
	}
}

@mixin mk-state($selector: &, $states: map.keys(ml.$utils-states), $no-state: 1) {
	@if not $selector {
		@error '`$selector` argument must not be null.';
	}

	@at-root {
		@if $no-state == 1 {
			#{$selector} {
				@content;
			}
		}

		$selector: ml.check-class($selector, 1);

		@each $key, $value in ml.$utils-states {
			@if list.index($states, $key) {
				$prefix: '.' + $key;

				@if meta.type-of($value) == 'string' {
					#{$prefix}_#{$selector}:#{$value} {
						@content;
					}
				} @else if meta.type-of($value) == 'list' {
					$multi-selector: ();

					@each $item in $value {
						$multi-selector: list.append($multi-selector, $prefix + '_' + $selector + ':' + $item, comma);
					}

					#{$multi-selector} {
						@content;
					}
				} @else {
					#{$prefix}_#{$selector} {
						@content;
					}
				}
			}
		}
	}
}

@mixin mk-util($name, $values, $bp: null, $states: null, $prop: null) {
	$util-name: ml.check-class($name, 1);
	$prop: if($prop, $prop, ml.util-prop($util-name));

	@if list.index($-utils-directed, $util-name) {
		$util-name: if($prop, $util-name, null);
		$utils-db: ml.parse-util-directions($values, $util-name);
		$utils-map: map.get($utils-db, 'utils-map');

		@each $key, $value in $utils-map {
			$util-index: list.index($utils-map, ($key $value));

			@include -generate-util(
				$key,
				$value,
				$bp,
				$states,
				list.nth(map.get($utils-db, 'props'), $util-index),
				list.nth(map.get($utils-db, 'directions'), $util-index)
			);
		}
	} @else {
		@include -generate-util($name, $values, $bp, $states, $prop);
	}
}

// Private mixin that generate utilities CSS.

@mixin -generate-util($name, $values, $bp: null, $states: null, $prop: null, $direct: null) {
	$name: ml.check-class($name);

	@each $key, $value in $values {
		$util-val-data: ml.parse-util($key);
		$bp-name: map.get($util-val-data, 'mq');
		$bp-name: if($bp-name, $bp-name, $bp);
		$util-parsed-val: map.get($util-val-data, 'value');

		$selector: $name + $util-parsed-val;
		$css-value: if($value, $value, ml.convert-util-value($util-parsed-val, $name));

		@if $bp-name == 'all' or $bp-name == 'bp' {
			@include bp-all($selector, if($bp-name == 'all', 1, 0)) {
				@include mk-state(&, $states, if($states, 0, 1)) {
					@include -check-util-direction($direct, $prop, $css-value);
				}
			}
		} @else if $bp-name {
			@include ml.bpm($bp-name) {
				#{$selector}_#{$bp-name} {
					@include mk-state(&, $states, if($states, 0, 1)) {
						@include -check-util-direction($direct, $prop, $css-value);
					}
				}
			}
		} @else {
			#{$selector} {
				@include mk-state(&, $states, if($states, 0, 1)) {
					@include -check-util-direction($direct, $prop, $css-value);
				}
			}
		}
	}
}

// Private mixin that parses combined directions and identifies positioning utilities.

@mixin -check-util-direction($dir, $prop, $value) {
	@if $dir == 'x' {
		$prop: if($prop, $prop + '-', '');
		@include -parse-unit($prop + 'right', $value, 'r');
		@include -parse-unit($prop + 'left', $value, 'l');
	} @else if $dir == 'y' {
		$prop: if($prop, $prop + '-', '');
		@include -parse-unit($prop + 'top', $value, 't');
		@include -parse-unit($prop + 'bottom', $value, 'b');
	} @else if $dir == 'all' {
		$prop: if($prop, $prop + '-', '');
		@each $item in map.values(ml.$main-directions) {
			@include -parse-unit($prop + $item, $value, string.slice($item, 1, 1));
		}
	} @else {
		@include -parse-unit($prop, $value, $dir);
	}
}

// Private mixin that parses custom units based on directions.

@mixin -parse-unit($prop, $value, $dir) {
	$coef-val: ml.str2n($value + '_');

	@if meta.type-of($value) == 'number' and math.unit($value) == 'gg' {
		$tmp-val: if($dir == 't' or $dir == 'b', $-gtr-sm-rem, 1);
		$dash-pos: string.index($prop, '-');

		@if $dash-pos and $dir and $dir != 'xy' {
			$prop: string.slice($prop, 1, $dash-pos - 1);
		} @else if $dir != 'xy' {
			$dir: 'xy';
		}

		@include ml.mk-gtr($tmp-val, $type: $prop, $direct: $dir, $coef: $coef-val);
	} @else if meta.type-of($value) == 'number' and math.unit($value) == 'su' {
		@if $dir == 'xy' {
			@include ml.mk-gtr-xy($prop, ml.$su * $coef-val, $-su-rem * $coef-val);
		} @else {
			$tmp-val: if($dir == 't' or $dir == 'b', $-su-rem, ml.$su);
			#{$prop}: $tmp-val * $coef-val;
		}
	} @else {
		#{$prop}: $value;
	}
}

@mixin mk-utils-group($raw-name, $values, $components: ()) {
	$group-data: ml.new-parse-util($raw-name);
	$group-name: map.get($group-data, 'value');

	@if not map.has-key(ml.$utils-db, 'groups', 'registry', $group-name) {
		@error 'Group `#{$group-name}` not defined in registry';
	}

	@if list.length($components) > 0 {
		$group-data: $components;
	}

	$i: 1;

	@each $util in map.get(ml.$utils-db, 'groups', 'registry', $group-name) {
		@include mu.new-mk-util(
			$util,
			$values,
			if(string.index($util, ml.$tUCm), (), $group-data),
			('groupItemIndex': $i)
		);

		$i: $i + 1;
	}
}

@mixin apply-util($utils, $components: ()) {
	@each $item in $utils {
		$util-data: ml.new-parse-util($item);
		$abbr-data: ml.parse-abbr(map.get($util-data, 'value'));
		$util-data: map.merge($util-data, $components);
		$keyword: ml.$kStOnly;
		$pre-states: map.get($util-data, 'pre-states');
		$post-states: map.get($util-data, 'post-states');

		@if map.get($util-data, 'at-rules') {
			$keyword: ml.$kArStOnly;
			// It's a bit dangerous to use non-standard fields in map, but it is unlikely that a way to check keywords in the `mk-util` will change
			$util-data: map.set($util-data, 'applyArKw', ml.$kArOnly);
		}

		@if $pre-states or $post-states {
			@if $pre-states and $post-states {
				$util-data: map.merge(
					$util-data,
					(
						'pre-states': '#{ml.$states-cmb} ' + $pre-states,
						'post-states':'#{ml.$states-cmb} ' + $post-states,
					)
				);
			}

			$util-data: map.set($util-data, 'applyStKw', $keyword);
		}

		@include mu.new-mk-util(
			map.get($abbr-data, 'name'),
			map.get($abbr-data, 'value'),
			map.remove($util-data, 'value'),
			('selector': &)
		);
	}
}

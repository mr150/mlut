@use 'sass:meta';
@use 'sass:list';
@use 'sass:map';
@use 'sass:math';
@use 'sass:string';

@use '../forward-tools' as mlu;
@use '../../functions/general' as mgf;
@use '../general' as mgen;
@use '../grid' as mgs;
@use 'mk-state' as mst;

@mixin new-mk-util($raw-name, $values, $features: (), $options: null) {
	$util-data: mlu.new-parse-util($raw-name);
	$util-name: map.get($util-data, 'value');

	$main-options: -util-main-options($util-name, $options);
	$class-name: map.get($main-options, 'class-name');
	$props: map.get($main-options, 'properties');

	@if not map.has-key(mlu.$utils-data, 'utils', 'registry', $util-name) {
		mlu.$utils-data: map.set(
			mlu.$utils-data, 'utils', 'registry', $util-name, if($options, $options, $props)
		);
	}

	$util-map: ();
	$util-data: map.merge($util-data, $features);
	$is-values-map: meta.type-of($values) == 'map';
	$i: 1;

	@each $key, $value in $values {
		$range-list: if($is-values-map, $key, list.nth($values, $i));

		@if list.is-bracketed($range-list) {
			@include new-mk-util(
				$util-name,
				$options: $options,
				mlu.parse-util-value-range($range-list, $util-name)...
			);
		} @else {
			$util-val-data: mlu.new-parse-util($key);

			@if list.length($util-val-data) < 2 {
				$util-val-data: map.merge($util-data, $util-val-data);
			}

			$util-parsed-val: map.get($util-val-data, 'value');
			$at-rules: map.get($util-val-data, 'at-rules');
			$post-states: map.get($util-val-data, 'post-states');
			$pre-states: map.get($util-val-data, 'pre-states');
			$is-important: map.get($util-val-data, 'important');
			$css-values: $value;

			@if $css-values == null {
				$css-values: mlu.convert-util-value($util-parsed-val, $util-name);
			} @else if $css-values == false {
				$css-values: $util-parsed-val;
			}

			$separated-value: if(
				$class-name == '',
				$util-parsed-val,
				mlu.util-separated-value($util-parsed-val),
			);

			@if $is-important {
				$separated-value: $separated-value + mlu.$tUIm;
			}

			$selector: mlu.str-escape($class-name + $separated-value);
			$this-util: (
				'name': $class-name,
				'value': $separated-value
			);

			$val-feat-str: mgf.ls-implode(
				map.values(map.remove($util-val-data, 'value')), ' '
			);

			$st-only: string.index($val-feat-str, mlu.$kStOnly);
			$ar-st-only: string.index($val-feat-str, mlu.$kArStOnly);
			$ar-st: string.index($val-feat-str, mlu.$kArSt);
			$args: (
				$props,
				$css-values,
				$is-important,
				map.get($main-options, 'repeat-prop-values'),
				map.get($main-options, 'preset-properties'),
				$util-name,
				$util-parsed-val,
			);

			@if not string.index($val-feat-str, mlu.$kArOnly) and not $ar-st-only {
				@include mst.new-mk-state(
					$post-states, $pre-states, not $st-only, $selector, $class-name
				) {
					@include -generate-props($args...);
				}
			}

			@if $at-rules {
				@include mgen.mk-ar($at-rules, $this-util) using ($ar) {
					.#{mlu.str-escape($ar + mlu.$tUCm) + $selector} {
						@if not $ar-st-only {
							@include -generate-props($args...);
						}

						@if $ar-st or $ar-st-only {
							@include mst.new-mk-state($post-states, $pre-states, false, &, $class-name) {
								@include -generate-props($args...);
							}
						}
					}
				}
			}
		}

		$i: $i + 1;
	}
}

@mixin -generate-props(
	$props, $values, $is-important, $repeat-values, $preset-props, $util, $util-value
) {
	$i: if($repeat-values == null, 0, 1);
	$values-count: list.length($values);
	$important: $is-important and string.unquote('!important');

	$css-values: if(
		list.length($props) < 2 and $values-count > 1,
		($values,),
		$values
	);

	@if $preset-props {
		@each $key, $value in $preset-props {
			#{$key}: if(
				meta.type-of($value) == 'function',
				meta.call($value, $util, $util-value, $values, $important),
				$value
			);
		}
	}

	@each $item in $props {
		@if $repeat-values == null {
			#{$item}: list.nth($css-values, ($i % $values-count) + 1) $important;
		} @else if $i <= $values-count {
			#{$item}: list.nth($css-values, $i) $important;
		}

		$i: $i + 1;
	}
}

@function -util-main-options($name, $options) {
	$prop: null;

	$result: (
		'class-name': if(
			map.has-key(mlu.$utils-data, 'utils', 'registry', $name, 'class-name'),
			map.get(mlu.$utils-data, 'utils', 'registry', $name, 'class-name'),
			$name
		),
		'repeat-prop-values': map.get(
			mlu.$utils-data, 'utils', 'registry', $name, 'repeat-prop-values'
		),
		'preset-properties': map.get(
			mlu.$utils-data, 'utils', 'registry', $name, 'preset-properties'
		),
	);

	@if meta.type-of($options) == 'map' {
		$prop: map.get($options, 'properties');
		$result: map.merge($result, $options);
	} @else if $options {
		$prop: $options;
	}

	@return map.set(
		$result, 'properties', $prop or mlu.util-prop($name, 'utils', true)
	);
}

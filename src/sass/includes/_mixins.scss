/*
Mixins

Useful mixins. All MLUT mixins have 'mlu' prefix. You can find all mixins in `sass/includes/_mixins.scss`.

Styleguide: sass-tools.mixins
*/

$mlu-su-rem: mlu-px2rem($mlu-su);
$mlu-gtr-sm-rem: mlu-px2rem($mlu-gtr-sm);

// mlu-bpm
//
// Bpm is breakpoint manager.
// ```scss
// @include mlu-bpm("md") {
//		.input--common {
//			padding-left: 48px;
//		}
// }
//
// @include mlu-bpm($to: "lg") {
//		.btn--common {
//			margin-left: 48px;
//		}
// }
//
// @include mlu-bpm("sm", "lg") {
//		.btn--common {
//			margin-top: 48px;
//		}
// }
// ```
// Compile into:
// ```css
// @media (min-width: 760px) {
//		.input--common {
//			padding-left: 48px;
//		}
// }
//
// @media (max-width: 959px) {
//		.btn--common {
//			margin-left: 48px;
//		}
// }
//
// @media (min-width: 520px) and (max-width: 959px) {
//		.btn--common {
//			margin-top: 48px;
//		}
// }
// ```
//
// $from = false - breakpoint. Can be keyword (string) or number. Generate to 'min-width' mediaquery, and `$to` to 'max-width' - 1.
// $to = false - breakpoint. Can be keyword (string) or number. Generate to 'max-width' - 1 mediaquery. Together with `$from` generate to 'min-width and max-width - 1'.
// $opt = false - string with additional media-features to check.
// For example:
// `(orientation: landscape)`,
// `screen and (aspect-ratio: 11/5)`,
// `print`.
// $prop = "width" - property in mediaquery. Property generate like `#{$type}-#{$prop}`,
// where `$type` can be 'min' or 'max'.
// `$type` depends on availability `$from` and `$to`
// @content - CSS relus that will be placed into mediaquery.
//
// Styleguide: sass-tools.mixins.bpm

@mixin mlu-bpm($from: false, $to: false, $opt: false, $prop: "width") {
	$type: "min";
	$bp-val: ();

	@if $from and $to {
		$type: "range";
	} @else if $to {
		$type: "max";
	} @else if not $from {
		@error "Breakpoint value must be not null.";
	}

	@each $item in ($from, $to) {
		@if type-of($item) == "string" {
			$bp-val: append($bp-val,
			if($item == $to,
			mlu-bp($item) - 1,
			mlu-bp($item)));
		} @else if type-of($item) == "number" and not unitless($item) {
			$item-to: $item;

			@if unit($item) == "em" {
				$item-to: mlu-px2em((($item / 1em) * $MLU-BROWSER-FONT-SIZE) - 1, $MLU-BROWSER-FONT-SIZE);
			} @else if unit($item) == "rem" {
				$item-to: mlu-px2rem((($item / 1rem) * $MLU-BROWSER-FONT-SIZE) - 1, $MLU-BROWSER-FONT-SIZE);
			} @else if unit($item) == "px" {
				$item-to: $item - 1;
			}

			$bp-val: append($bp-val,
			if($item == $to, $item-to, $item));
		} @else if type-of($item) != "bool" or (type-of($item) == "bool" and $item) {
			@error "Invalid breakpoint type: '#{type-of($item)}' or value: '#{$item}'";
		}
	}

	$opt: if($opt, $opt + " ", "");
	$media-str: "";

	@if $type == "range" {
		$media-str: $opt + "(min-" + $prop + ":" + nth($bp-val, 1) + ") and (max-" + $prop + ":" + nth($bp-val, 2) + ")";
	} @else {
		$bp-val: nth($bp-val, 1);
		$media-str: $opt + "(" + $type + "-" + $prop + ":" + $bp-val + ")";
	}

	@media #{$media-str} {
		@content;
	}
}

// mlu-sprite-mods
//
// Generator BEM modifiers for block with [icon](#kssref-sass-tools-mixins-sprite_icon).
// ```scss
//$icons: (
//		"vk": (27px, 16px, -5px, -5px),
//		"fb": (13px, 28px, -27px, -5px),
//);
//
//.soc-icon {
//		@include mlu-sprite-mods($icons);
//}
// ```
// CSS
// ```css
//.soc-icon--vk:before {
//		width: 27px;
//		height: 16px;
//		background-position-x: -5px;
//}
//
//.soc-icon--fb:before {
//		width: 13px;
//		height: 28px;
//		background-position-x: -27px;
//}
// ```
//
// $sprite - map with icons data. Icon rendered as a pseudo-element.
// Sprite item example: `modifier-name: (width, height, bgpx, bgpy)`. <br>
// If icons have the same sizes you can write in map only 2 params: `modifier-name: (bgpx, bgpy)`. <br>
// All icon data lists must be equal length. <br>
// If one or some parameters the same in all icons, it will not be
// generated in modifiers that DRY. Write repeating
// parameter in block class.
// $pseudo = "before" - pseudo-element in which the icon will be inserted.
//
// Styleguide: sass-tools.mixins.sprite_mods

@mixin mlu-sprite-mods($sprite, $pseudo: "before") {
	@if type-of($sprite) != "map" {
		@error "Wrong type of argument $sprite: '#{type-of($sprite)}'. Expected 'map'";
	}

	$diff-prop-flags: (false, false, false, false);
	$icons-data-list: map-values($sprite);

	@each $value in $icons-data-list {
		$i: index($icons-data-list, $value);

		@if $i > 1 {
			$prev-value: nth($icons-data-list, $i - 1);

			@if length($value) != length($prev-value) {
				@error "Invalid format of sprite item data: all icons data lists must have equal count of parameters";
			}

			@for $j from 1 through length($value) {
				@if nth($value, $j) != nth($prev-value, $j) {
					$diff-prop-flags: set-nth($diff-prop-flags, $j, 1);
				}
			}
		}
	}

	@each $key, $value in $sprite {
		$val-length: length($value);

		@at-root {
			&--#{$key}:#{$pseudo} {
				@if $val-length == 4 {
					@if nth($diff-prop-flags, 1) {
						width: nth($value, 1);
					}

					@if nth($diff-prop-flags, 2) {
						height: nth($value, 2);
					}
				} @else if $val-length != 2 {
					@error "Invalid format of sprite item data: '(#{$value})'. Expected 2 or 4 parameters";
				}

				@if nth($diff-prop-flags, $val-length - 1) and nth($diff-prop-flags, $val-length) {
					background-position: nth($value, $val-length - 1) nth($value, $val-length);
				} @else if nth($diff-prop-flags, $val-length - 1) {
					background-position-x: nth($value, $val-length - 1);
				} @else if nth($diff-prop-flags, $val-length) {
					background-position-y: nth($value, $val-length);
				}
			}
		}
	}
}

// mlu-def-hover
//
// Simple hover wich change color
// to lighter on hover and darker on active.
// ```scss
//.btn--common {
//		@include mlu-def-hover(#f00);
//}
// ```
// CSS
// ```css
//.btn--common:hover,
//.btn--common:focus {
//		background-color: #ff2929;
//}
//
//.btn--common:active {
//		background-color: #e60000;
//}
// ```
//
// $color - init color that will change.
// $prop = background-color - CSS property that will change.
// $lighten = 8% - percent on which the `$color` will become lighten
// with sass function `lighten` on `:hover`.
// $darken = $lighten-3 - the same at `$lighten` but `$color` will change
// on `:active`.
//
// Styleguide: sass-tools.mixins.def_hover

@mixin mlu-def-hover($color, $prop: "bgc", $lighten: 8%, $darken: ($lighten - 3)) {
	$prop: if($prop == "bgc", "background-color", $prop);

	&:hover,
	&:focus {
		#{$prop}: lighten($color, $lighten);
	}

	&:active {
		#{$prop}: darken($color, $darken);
	}
}

// mlu-mCl
//
// Generate clearfix for float layout.
// ```scss
//.block {
//		@include mlu-mCl;
//}
// ```
// CSS
// ```css
//.block:after {
//		display: table;
//		clear: both;
//		content: "";
//}
// ```
//
// Styleguide: sass-tools.mixins.mcl
@mixin mlu-mCl {
	&:after {
		display: table;
		clear: both;
		content: "";
	}
}

// mlu-mk-gtr
//
// Generate fields or indents in grid-gutters on different breakpoints.
// ```scss
//.block {
//		@include mlu-mk-gtr($direct: "r", $coef: 2);
//}
//
//.foo {
//		@include mlu-mk-gtr($direct: "r", $coef: 2, $css-vars: false);
//}
// ```
// CSS
// ```css
//.block {
//		margin-right: 32px;
//		margin-right: calc(var(--mlu-gg) * 2);
//}
//
//.foo {
//		margin-right: 24px;
//}
//
//@media (min-width: 960px) {
//		.foo {
//			margin-right: 32px;
//		}
//}
// ```
//
// $init-gutter = $mlu-gtr-sm - initial gutter value out of breakpoint.
// Can be number. If passed '-1', initial gutter will not be generated.
// If you need a gutter in `rem`, pass value in `rem`.
// $type = margin - can be any CSS property, including custom.
// If no `margin`, `padding` or custom property is used, then `$direct` = "xy" must be specified.
// $direct = "x" - can take 4 main directions from [$mlu-main-directions](#kssref-sass-tools-settings-general)
// or combined direction: 'x'(left right), 'y'(top bottom)
// and 'xy'(left right top bottom).
// $gutters = $mlu-grid-gutters - map with gutters values on breakpoints.
// Map item example: `"sm": 12px`. Custom gutters only work when the `$css-vars = false`.
// $calc = $MLU-FLAG-CALC-FALLBACK - bool flag for generation CSS `calc()` fallback for old browsers.
// $coef = 1 - coefficient by which the gutter value is multiplied.
// $css-vars = $MLU-FLAG-CSS-VARS - use [CSS custom properties](section-core-styles.html#kssref-core-styles-css_vars) for gutters.
// Works as a [similar flag](section-sass-tools.html#kssref-sass-tools-settings-flags) in the settings.
//
// Styleguide: sass-tools.mixins.mk_gtr

@mixin mlu-mk-gtr($init-gutter: $mlu-gtr-sm, $type: "margin",
$gutters: $mlu-grid-gutters, $calc: $MLU-FLAG-CALC-FALLBACK, $direct: "x",
$coef: 1, $css-vars: $MLU-FLAG-CSS-VARS) {
	$custom-prop: null;
	$prev-value: $mlu-grid-default-gtr;
	$direct-val: null;

	@if str-slice($type, 1, 2) == "--" {
		$direct: "xy";
		$custom-prop: $type;
	}

	@if type-of($gutters) != "map" {
		@error "Wrong type of argument $gutters: '#{type-of($gutters)}'. Expected 'map'";
	}

	@if map-has-key($mlu-main-directions, $direct) {
		$direct-val: map-get($mlu-main-directions, $direct);
	}

	@if not $css-vars {
		$prev-value: if(map-has-key($gutters, $mlu-bp-xs), map-get($gutters, $mlu-bp-xs), $init-gutter);
	}

	@if $init-gutter and $init-gutter != -1 {
		$var-value: if($coef != 1,
		calc(var(#{$--mlu-gg}) * #{$coef}),
		var(#{$--mlu-gg}));

		$var-value-rem: if($coef != 1,
		calc(var(#{$--mlu-gg-rem}) * #{$coef}),
		var(#{$--mlu-gg-rem}));

		$tmp-val: if($calc, calc(#{$prev-value * $coef}), $prev-value * $coef);

		$tmp-val-rem: if($calc,
		calc(#{mlu-px2rem($prev-value) * $coef}),
		mlu-px2rem($prev-value) * $coef);

		@if unit($init-gutter) == "rem" {
			$prev-value: mlu-px2rem($prev-value);
			$tmp-val: $tmp-val-rem;
			$var-value: $var-value-rem;
		}

		@if $direct == "x" {
			@if not $css-vars or $css-vars == 1 {
				#{$type}-right: if($calc, ($mlu-grid-gutter-fallback * $coef), $tmp-val);
				#{$type}-left: if($calc, ($mlu-grid-gutter-fallback * $coef), $tmp-val);
				#{$type}-right: $tmp-val;
				#{$type}-left: $tmp-val;
			}

			@if $css-vars {
				#{$type}-right: $var-value;
				#{$type}-left: $var-value;
			}
		} @else if $direct == "y" {
			@if not $css-vars or $css-vars == 1 {
				#{$type}-top: if($calc, ($mlu-gtr-sm * $coef), $tmp-val);
				#{$type}-bottom: if($calc, ($mlu-gtr-sm * $coef), $tmp-val);
				#{$type}-top: $tmp-val;
				#{$type}-bottom: $tmp-val;
			}

			@if $css-vars {
				#{$type}-top: $var-value;
				#{$type}-bottom: $var-value;
			}
		} @else if $direct == "xy" {
			@if not $css-vars or $css-vars == 1 {
				@if $calc {
					#{$type}: ($mlu-gtr-sm * $coef) ($mlu-grid-gutter-fallback * $coef);
				}

				@include _mlu-mk-gtr-xy($type, $tmp-val, $tmp-val-rem);
			}

			@if not $custom-prop and $css-vars {
				@include _mlu-mk-gtr-xy($type, $var-value, $var-value-rem);
			}
		} @else if $direct-val {
			@if not $css-vars or $css-vars == 1 {
				#{$type}-#{$direct-val}: if($calc, ($mlu-grid-gutter-fallback * $coef), $tmp-val);
				#{$type}-#{$direct-val}: $tmp-val;
			}

			@if $css-vars {
				#{$type}-#{$direct-val}: $var-value;
			}
		} @else {
			@error "Invalid gutter direction - '#{$direct}'";
		}
	}

	@if not $css-vars {
		@each $key, $value in $gutters {
			$cur-val: $value;

			@if $prev-value and unit($prev-value) == "rem" {
				$cur-val: mlu-px2rem($value);
			} @else if $prev-value and unitless($prev-value) and $prev-value > -1 {
				$cur-val: mlu-ston($value + "");
			}

			@if $prev-value != -1 and $cur-val != $prev-value {
				$tmp-val: if($calc, calc(#{$cur-val * $coef}), $cur-val * $coef);
				$tmp-val-rem: if($calc,
				calc(#{mlu-px2rem($cur-val) * $coef}),
				mlu-px2rem($cur-val) * $coef);

				@include mlu-bpm($key) {
					@if $direct == "x" {
						#{$type}-right: $tmp-val;
						#{$type}-left: $tmp-val;
					} @else if $direct == "y" {
						#{$type}-top: $tmp-val;
						#{$type}-bottom: $tmp-val;
					} @else if $direct == "xy" {
						@include _mlu-mk-gtr-xy($type, $tmp-val, $tmp-val-rem);
					} @else if $direct-val {
						#{$type}-#{$direct-val}: $tmp-val;
					} @else {
						@error "Invalid gutter direction - '#{$direct}'";
					}
				}
			}

			$prev-value: $cur-val;
		}
	}
}

// Private mixin to create gutters in the 'xy' direction.

@mixin _mlu-mk-gtr-xy($type, $value, $value-rem) {
	@if ($type == "padding" or $type == "margin") and ($value != $value-rem) {
		#{$type}: $value-rem $value;
	} @else {
		#{$type}: $value;
	}
}

// mlu-sprite-icon
//
// Generate block with icon from css-sprite in pseudo-element.
// ```scss
//.icon {
//		@include mlu-sprite-icon();
//}
// ```
// CSS
// ```css
//.icon {
//		position: relative;
//}
//
//.icon:before {
//		position: absolute;
//		background-image: url("../img/css_sprites.png");
//		background-repeat: no-repeat;
//		content: "";
//}
//```
//
// $sprite =  "../img/css_sprites.png" - path to css-sprite in png. Can be string.
// $pseudo = "before" - type of pseudo-element: before or after.
// @content - can take additional CSS into pseudo-element.
//
// Styleguide: sass-tools.mixins.sprite_icon

@mixin mlu-sprite-icon($sprite: "../img/css_sprites.png", $pseudo: "before") {
	position: relative;

	&:#{$pseudo} {
		position: absolute;
		background-image: url($sprite);
		background-repeat: no-repeat;
		content: "";

		@content;
	}
}

// mlu-circle
//
// Generate circle.
// ```scss
//.block {
//		@include mlu-circle(32px, #f00);
//}
// ```
// CSS
// ```css
//.block {
//		width: 32px;
//		height: 32px;
//		background-color: #f00;
//		border-radius: 50%;
//}
// ```
//
// $diametr - circle diametr. Can be number.
// $bgc = transparent - circle `background-color`. Can be color.
//
// Styleguide: sass-tools.mixins.circle

@mixin mlu-circle($diametr, $bgc: transparent) {
	width: $diametr;
	height: $diametr;
	background-color: $bgc;
	border-radius: 50%;
}

// mlu-triangle
//
// Generate blank for border triangle.
// ```scss
//.block {
//		@include mlu-triangle(14px);
//}
// ```
// CSS
// ```css
//.block {
//		width: 0px;
//		height: 0px;
//		border: 14px transparent solid;
//}
// ```
//
// $size - triangle size.
// For create triangle you need to add `border-color` for one of side
// after this mixin.
// For example: `border-top-color: #f00`.
//
// Styleguide: sass-tools.mixins.triangle

@mixin mlu-triangle($size) {
	width: 0px;
	height: 0px;
	border: $size transparent solid;
}

// mlu-bgi-hexagon
//
// Generate hexagon with CSS `linear-gradient()` in `background-image`. See demo [here](section-examples.html#kssref-examples-other).
// ```scss
//.block {
//		@include mlu-bgi-hexagon($bgc: (#306, #d15));
//}
// ```
// CSS
// ```css
//.block {
//		box-sizing: border-box;
//		background-repeat: no-repeat;
//		background-position: 0px 0px, 100% 0px, 50% 50%, 0px 102%, 100% 102%;
//		background-size: 51% 27%, 51% 27%, 100% 48%, 51% 28%, 51% 28%;
//		background-image: linear-gradient(150deg, transparent 50%, #306 50%), linear-gradient(-150deg, transparent 50%, #306 50%), linear-gradient(#306, #d15), linear-gradient(-330deg, transparent 50%, #d15 50%), linear-gradient(330deg, transparent 50%, #d15 50%);
//}
// ```
//
// $edge-ang = 150deg - linear-gradient angle of hexagon edges. Can be only number in `deg`.
// $edge-cs = 50% - is color-stop in linear-gradient of hexagon edges. Can be number with unit.
// $bgc = #000 - hexagon color. It can be single color or list in linear-gradient
// value format. For example: `(167deg, blue 50%, #f0f, #000)`. <br>
// Angle in gradient can be only number in `deg`. If you pass gradient value,
// top hexagon edge get first color, bottom edge get last color and
// hexagon body get full gradient.
// $body-size = (100% 48%) - `background-size` of linear-gradient of hexagon body.
// $change = false - bool flag for generate a change in color or size of an existing hexagon.
//
// Styleguide: sass-tools.mixins.bgi_hexagon

// Hexagon
//
// Hexagon demo generated with [mlu-bgi-hexagon](section-sass-tools.html#kssref-sass-tools-mixins-bgi_hexagon) mixin.
//
// Markup:
// <div class="test-hex"></div>
//
// Styleguide: examples.other.hexagon

@mixin mlu-bgi-hexagon($edge-ang: 150deg, $edge-cs: 50%, $bgc: #000,
$body-size: (100% 48%), $change: false) {

	@if not (type-of($edge-ang) == "number" and unit($edge-ang) == "deg") {
		@error "Invalid value of argument $edge-and - '#{$edge-ang}'. Expected angle in deg.";
	}

	$first-color: $bgc;
	$last-color: $first-color;
	$body-gradient: ($bgc, $bgc);
	$edge-ang-bot: $edge-ang + 180;

	@if type-of($bgc) == "list" {
		$first-color: nth(nth($bgc, 1), 1);
		$val-type: type-of($first-color);

		@if $val-type == "number" and unit($first-color) == "deg" {
			$first-color: nth(nth($bgc, 2), 1);
		} @else if $val-type != "color" or ($val-type == "number" and unitless(nth($bgc, 1))) {
			@error "Invalid gradient format: first value can be angle in deg or color but now value is '#{$first-color}'";
		}

		$last-color: nth(nth($bgc, length($bgc)), 1);
		$body-gradient: $bgc;
	} @else if type-of($bgc) != "color" {
		@error "Wrong type of argument $bgc: '#{type-of($bgc)}'. Expected 'color' or 'list'";
	}

	@if not $change {
		box-sizing: border-box;
		background-repeat: no-repeat;
		background-position: 0px 0px, 100% 0px, 50% 50%, 0px 102%, 100% 102%;
	}

	@if not $change or $body-size != (100% 48%) {
		background-size: 51% 27%, 51% 27%, $body-size, 51% 28%, 51% 28%;
	}

	background-image: linear-gradient($edge-ang, transparent $edge-cs, $first-color $edge-cs),
		linear-gradient(-$edge-ang, transparent $edge-cs, $first-color $edge-cs),
		linear-gradient($body-gradient),
		linear-gradient(-$edge-ang-bot, transparent $edge-cs, $last-color $edge-cs),
		linear-gradient($edge-ang-bot, transparent $edge-cs, $last-color $edge-cs);
}

// mlu-restore-Ol
//
// Restore default browser outline on focus state.
// ```scss
//.link {
//		@include mlu-restore-Ol;
//}
// ```
// CSS
// ```css
//.link:focus {
//		outline: 1px dotted #212121;
//		outline: -webkit-focus-ring-color auto 5px;
//}
// ```
//
// Styleguide: sass-tools.mixins.restore_ol

@mixin mlu-restore-Ol {
	&:focus {
		outline: 1px dotted #212121;
		outline: -webkit-focus-ring-color auto 5px;
	}
}

// mlu-ie11-Ai-c
//
// Hack for [bug](https://github.com/philipwalton/flexbugs/issues/231) with `align-items: center` and `min-height` in IE11. No side effects were noticed in other browsers, but be careful using this.
// ```scss
//.foo {
//		@include mlu-ie11-Ai-c;
//}
// ```
// CSS
// ```css
//.foo:after {
//		min-height: inherit;
//		font-size: 0;
//		content: "";
//}
// ```
//
// Styleguide: sass-tools.mixins.ie11_aic

@mixin mlu-ie11-Ai-c {
	&:after {
		min-height: inherit;
		font-size: 0;
		content: "";
	}
}

// mlu-W
//
// Set `width` on different breakpoints.
// It works similarly like [W utility](section-core-utils.html#kssref-core-utils-bxz-w).
// ```scss
//.block {
//		@include mlu-W(2, "sm");
//		@include mlu-W(3gc, "md");
//		@include mlu-W(4gs, "lg");
//}
//
//.foo {
//		@include mlu-W(2gc, "sm", $css-vars: false);
//}
// ```
// CSS
// ```css
//@media (min-width: 520px) {
//		.block {
//			--gc: 2;
//			width: calc(16.666% - 32px);
//			width: var(--gc-rule, 16.666%);
//		}
//
//		.foo {
//			width: calc(16.666% - 24px);
//		}
//}
//
//@media (min-width: 760px) {
//		.block {
//			width: calc(25% - 32px);
//			width: calc(25% - var(--mlu-gg) * 2);
//		}
//}
//
//@media (min-width: 960px) {
//		.block {
//			width: 33.333%;
//		}
//
//		.foo {
//			width: calc(16.666% - 32px);
//		}
//}
// ```
//
// $width - can be in grid-columns(simple - `gc`, variable - unitless number), grid-spans(`gs`),
// any CSS units(`px`, `rem` etc) or `auto`. <br> Grid units calculated to %
// according to the formula '`n / $cols * 100%`' and rounded by
// [mlu-decimal-floor](section-sass-tools.html#kssref-sass-tools-functions-decimal_floor). <br>
// If `$width = "gc"` and `$css-vars = false`, width will generated with considering
// different gutters on breakpoints. As in the example above `foo`
// on `lg`.
// $bp = $mlu-bp-xs - breakpoint on which `$width` will sets. Can be number or breakpoint name.
// $cols = $mlu-grid-default-cols - columns count in grid. Can be number or breakpoint name.
// $gutters = $mlu-grid-gutters - map with gutters values on breakpoints.
// Map item example: `"sm": 12px`. Custom gutters only work when the `$css-vars = false`.
// $calc = false - bool flag for generation CSS `calc()` fallback. It can needed only if
// $width set in 'gc' unit.
// $type = "width" - service argument which used only by mixins-wrappers.
// It needed for reusable `mlu-W` for generating grid offset,
// because the algorithm for generating them is the same.
// $css-vars = $MLU-FLAG-CSS-VARS - use [CSS custom properties](section-core-styles.html#kssref-core-styles-css_vars) for gutters.
// Works as a [similar flag](section-sass-tools.html#kssref-sass-tools-settings-flags) in the settings.
//
// Styleguide: sass-tools.mixins.w

@mixin mlu-W($width, $bp: $mlu-bp-xs, $cols: $mlu-grid-default-cols, $gutters: $mlu-grid-gutters, $css-vars: $MLU-FLAG-CSS-VARS, $calc: $MLU-FLAG-CALC-FALLBACK, $type: "width") {
	$col-width: 0;
	$columns: $cols;
	$grid-gutters: $gutters;
	$xs-gutter: false;
	$calc-fallback: $calc;
	$custom-unit: "";
	$valid-values: (
		"auto",
		"inherit",
	);

	@if type-of($cols) == "string" {
		$columns: mlu-grid-cols-count($cols);
	} @else if type-of($cols) != "number" {
		@error "Invalid value of argument $cols: '#{$cols}'. Expected number value or breakpoint name";
	}

	@if type-of($width) == "number" and
		(unitless($width) or unit($width) == "gc" or unit($width) == "gs") {
		$tmp-val: mlu-ston($width + "");
		$col-width: mlu-decimal-floor($tmp-val / $columns * 100%, 3);
		$custom-unit: if(unit($width) == "gc", "gc", "gs");
		$custom-unit: if(unitless($width), $width, $custom-unit);
	} @else if type-of($width) == "number" or index($valid-values, $width) {
		$col-width: $width;
	} @else if type-of($width) != "number" {
		@error "Invalid value of argument $width: '#{$width}'. Expected number value or CSS keyword";
	}

	@if type-of($gutters) == "number" {
		$grid-gutters: (if($bp == $mlu-bp-xs, $mlu-bp-sm, $bp): $gutters);
	} @else if type-of($gutters) == "map" {
		$xs-gutter: map-get($gutters, $mlu-bp-xs);
	} @else {
		@error "Wrong type of argument $gutters: '#{type-of($gutters)}'. Expected 'number' or 'map'";
	}

	@if $bp == $mlu-bp-xs {
		$prev-gutter: if($xs-gutter, $xs-gutter, $mlu-gtr-sm);
		@if $css-vars {
			$prev-gutter: $mlu-grid-default-gtr;
		}

		@include _mlu-mk-width($col-width, $custom-unit, $prev-gutter, $calc-fallback, $type, $css-vars);
		$calc-fallback: false;

		// Repeat generation utility with new gutter if it changed on breakpoint.
		// It need for utilities for smaller breakpoints correct work
		// on larger breakpoints with changed gutter
		@if not $css-vars {
			@each $key, $value in $grid-gutters {
				@if $value != $prev-gutter and $custom-unit == "gc" {
					@include mlu-bpm($key) {
						@include _mlu-mk-width($col-width, $custom-unit, $value, $calc-fallback, $type);
					}
				}

				$prev-gutter: $value;
			}
		}
	} @else if $custom-unit == "gc" and not $css-vars {
		@if not map-has-key($grid-gutters, $bp) {
			$grid-gutters: map-merge($grid-gutters, ($bp: nth(nth($grid-gutters, length($grid-gutters)), 2)));
		}

		$col-gutter: map-get($grid-gutters, $bp);
		$prev-gutter: $col-gutter;

		@each $key, $value in $grid-gutters {
			// Repeat generation utility with new gutter if it changed on breakpoint.
			@if $key == $bp or ($value > $col-gutter and $value != $prev-gutter) {
				@include mlu-bpm($key) {
					@include _mlu-mk-width($col-width, $custom-unit, $value, $calc-fallback, $type);
					$calc-fallback: false;
				}

				$prev-gutter: $value;
			}
		}
	} @else {
		@include mlu-bpm($bp) {
			@include _mlu-mk-width($col-width, $custom-unit, $mlu-grid-default-gtr, $calc, $type, $css-vars);
		}
	}
}

// mlu-Ml
//
// Set `margin-left` on different breakpoints.
// It works similarly like [Ml utility](section-core-utils.html#kssref-core-utils-margin-ml).
//
// It wrapper on [mlu-W](#kssref-sass-tools-mixins-w) because calculating and generation algorithm
// for grid columns width and grid offsets the same. <br>
// All parameters are the same as in `mlu-W`. Only the first parameter is called `$offset`.
// ```scss
//.block {
//		@include mlu-Ml(1, "sm");
//		@include mlu-Ml(3gc, "lg");
//		@include mlu-Ml(4gs, "lg");
//}
// ```
// CSS
// ```css
//@media (min-width: 520px) {
//		.block {
//			--mgc: 1;
//			margin-left: calc(8.333% + 16px);
//			margin-left: var(--mgc-rule, 8.333%);
//		}
//}
//
//@media (min-width: 960px) {
//		.block {
//			margin-left: calc(25% + 16px);
//			margin-left: calc(25% + var(--mlu-gg));
//		}
//
//		.block {
//			margin-left: 33.333%;
//		}
//}
// ```
//
// $offset - can be in grid-columns(simple - `gc` unit, variable - unitless number), grid-spans(`gs`),
// any CSS units(`px`, `rem` etc) or `auto`.
//
// Styleguide: sass-tools.mixins.ml

@mixin mlu-Ml($offset, $bp: $mlu-bp-xs, $cols: $mlu-grid-default-cols, $gutters: $mlu-grid-gutters, $css-vars: $MLU-FLAG-CSS-VARS, $calc: $MLU-FLAG-CALC-FALLBACK) {
	@include mlu-W($offset, $bp, $cols, $gutters, $css-vars, $calc, "margin-left");
}

// Private mixin for width and grid offset generation from 'mlu-W'.

@mixin _mlu-mk-width($width, $unit, $gutter: $mlu-gtr-sm,
$calc: false, $prop: "width", $css-vars: false) {
	$prop-abbr: (
		"width": "",
		"margin-left": "m",
		"max-width": "maw",
	);

	$var-width: if(type-of($unit) == "number", $unit, null);
	$unit: if($var-width, "gc", $unit);
	$calc-val: calc(#{$width} - #{$gutter * 2});
	$var-val: calc(#{$width} - var(#{$--mlu-gg}) * 2);
	$width-fallback: if($calc, mlu-decimal-floor($width, 3) - ($mlu-grid-gutter-fallback * 2), 0);

	@if $prop == "margin-left" {
		$calc-val: calc(#{$width} + #{$gutter});
		$var-val: calc(#{$width} + var(#{$--mlu-gg}));
		$width-fallback: if($calc, mlu-decimal-floor($width, 3) + $mlu-grid-gutter-fallback, 0);
	}

	// Generation calc() fallback
	@if $calc and $unit == "gc" {
		#{$prop}: $width-fallback;
	}

	@if $unit == "gc" {
		$abbr: map-get($prop-abbr, $prop);

		@if $var-width {
			--#{$abbr}gc: #{$var-width};
		}

		@if not $css-vars or $css-vars == 1 {
			#{$prop}: $calc-val;
		}

		@if $css-vars and not $var-width {
			#{$prop}: $var-val;
		} @else if $var-width {
			#{$prop}: var(--#{$abbr}gc-rule, #{$width});
		}
	} @else {
		#{$prop}: $width;
	}
}

// mlu-row
//
// Generate [row](section-core-blocks.html#kssref-core-blocks-row) block styles.
// ```scss
//.block {
//		@include mlu-row;
//}
// ```
//
// $display = block - display type. Can be value of CSS `display` property.
//
// Styleguide: sass-tools.mixins.row

@mixin mlu-row($display: block) {
	position: relative;
	display: $display;
	margin: 0px;
	padding: 0px;
	font-size: 0px;
	list-style: none;
	counter-reset: mlu-row-item;
}

// mlu-row-col
//
// Generate styles for [row__col](section-core-blocks.html#kssref-core-blocks-row-row__col) element.
// ```scss
//.item {
//		@include mlu-row-col;
//}
// ```
//
// $display = inline-block - display type. Can be value of CSS `display` property.
// $gutters = $mlu-grid-gutters - map with column gutters values on breakpoints.
// You can also pass a number if you need the same gutter on all breakpoints.
// Custom gutters only work when the `$css-vars = false`.
// $calc = false - bool flag for generation CSS `calc()` fallback. It can needed only
// for "col" `$type`.
// $type = "col" - service parameter which used only by mixins-wrappers.
// It needed for reusable `mlu-row-col` for making other
// `row` elements, because the most of styles for them is the same.
// $css-vars = $MLU-FLAG-CSS-VARS - use CSS custom properties for gutters.
// Works as a [similar flag](section-sass-tools.html#kssref-sass-tools-settings-flags) in the settings.
//
// Styleguide: sass-tools.mixins.row_col

@mixin mlu-row-col($display: inline-block, $gutters: $mlu-grid-gutters,
$css-vars: $MLU-FLAG-CSS-VARS, $calc: $MLU-FLAG-CALC-FALLBACK, $type: "col") {
	$grid-gutters: $gutters;

	@if type-of($gutters) == "number" {
		$grid-gutters: ($mlu-bp-xs: $gutters);
	} @else if type-of($gutters) != "map" {
		@error "Wrong type of argument $gutters: '#{type-of($gutters)}'. Expected 'number' or 'map'";
	}

	@if $css-vars {
		--gc-rule: calc(var(--gc) / var(#{$--mlu-grid-cols}) * 100% - var(--gc-diff) * 2);
		--mgc-rule: calc(var(--mgc) / var(#{$--mlu-grid-cols}) * 100% + var(--gc-diff));
	}

	position: relative;
	display: $display;
	max-width: 100%;
	box-sizing: border-box;
	font-size: $mlu-base-font-size;
	font-size: mlu-px2rem($mlu-base-font-size);
	text-align: left;
	vertical-align: top;
	white-space: normal;
	direction: ltr;

	@if $type == "col" {
		--gc-diff: var(#{$--mlu-gg});

		@include mlu-W(12gc, $gutters: $grid-gutters, $css-vars: $css-vars, $calc: $calc);

		@include mlu-mk-gtr($mlu-gtr-sm, $gutters: $grid-gutters, $calc: $calc, $css-vars: $css-vars);
		@include mlu-mk-gtr($mlu-gtr-sm, $gutters: $grid-gutters, $calc: $calc, $direct: "b", $coef: 2, $css-vars: $css-vars);

		&.row {
			margin-bottom: 0px;
			font-size: 0px;
		}
	} @else {
		--gc-diff: 0px;

		&.row {
			font-size: 0px;
		}
	}

	& > :first-child:not([class]) {
		margin-top: 0px;
	}

	& > :last-child:not([class]) {
		margin-bottom: 0px;
	}
}

// mlu-row-item
//
// Generate styles for [row__item](section-core-blocks.html#kssref-core-blocks-row-row__item) element.
//
// It mixin-wrapper on `mlu-row-col` because most of styles the same.
// ```scss
//.item {
//		@include mlu-row-item;
//}
// ```
//
// $display = inline-block - display type. Can be value of CSS `display` property.
//
// Styleguide: sass-tools.mixins.row_item

@mixin mlu-row-item($display: inline-block) {
	@include mlu-row-col($display, $type: "item");
}

// mlu-bp-all
//
// Generates the CSS rule on breakpoints, adding the name of the breakpoint to the selector, inside the corresponding media query.
//
// ```scss
//@include mlu-bp-all(".Bdw1") {
//		border-width: 1px;
//}
// ```
// CSS
// ```css
//.Bdw1 {
//		border-width: 1px;
//}
//
//@media (min-width: 520px) {
//		.Bdw1_sm {
//			border-width: 1px;
//		}
//}
//
//@media (min-width: 760px) {
//		.Bdw1_md {
//			border-width: 1px;
//		}
//}
//
//@media (min-width: 960px) {
//		.Bdw1_lg {
//			border-width: 1px;
//		}
//}
//
//@media (min-width: 1168px) {
//		.Bdw1_xl {
//			border-width: 1px;
//		}
//}
// ```
// You can also use mixin inside the rule. This will work as well as the example above:
// ```scss
//.Bdw1 {
//		@include mlu-bp-all() {
//			border-width: 1px;
//		}
//}
// ```
//
// $selector = & - selector of CSS rule. Can be `string` or `&`.
// $xs = 1 - any type flag. If equal to 1, then the rule will first be generated outside of breakpoints(in `xs`).
//
// Styleguide: sass-tools.mixins.bp_all

@mixin mlu-bp-all($selector: &, $xs: 1) {
	@if not $selector {
		@error "'$selector' argument must not be null.";
	}

	@at-root {
		@if $xs == 1 {
			#{$selector} {
				@content;
			}
		}

		@each $key, $value in $mlu-breakpoints {
			@include mlu-bpm($key) {
				#{$selector}_#{$key} {
					@content;
				}
			}
		}
	}
}

@mixin mlu-mk-state($selector: &, $states: map-keys($mlu-util-states), $no-state: 1) {
	@if not $selector {
		@error "'$selector' argument must not be null.";
	}

	@at-root {
		@if $no-state == 1 {
			#{$selector} {
				@content;
			}
		}

		$selector: mlu-check-class($selector, 1);

		@each $key, $value in $mlu-util-states {
			@if index($states, $key) {
				$prefix: "." + $key;

				@if type-of($value) == "string" {
					#{$prefix}_#{$selector}:#{$value} {
						@content;
					}
				} @else if type-of($value) == "list" {
					$multi-selector: ();

					@each $item in $value {
						$multi-selector: append($multi-selector, $prefix + "_" + $selector + ":" + $item, comma);
					}

					#{$multi-selector} {
						@content;
					}
				} @else {
					#{$prefix}_#{$selector} {
						@content;
					}
				}
			}
		}
	}
}

@mixin mlu-mk-util($name, $prop, $map, $bp: false, $states: false, $direct: null) {
	$name: mlu-check-class($name);

	@each $key, $value in $map {
		$bp-name: $bp;
		$util-val: $key;
		$separator: if(type-of($key) == "string", str-index($key, "_"), false);

		@if $separator {
			$bp-name: str-slice($util-val, $separator + 1);
			$util-val: str-slice($util-val, 1, $separator - 1);
		}

		$separator: if(mlu-ston($util-val), "", "-");
		$selector: $name + $separator + $util-val;

		@if $bp-name == "all" or $bp-name == "bp" {
			@include mlu-bp-all($selector, if($bp-name == "all", 1, 0)) {
				@include mlu-mk-state(&, $states, if($states, 0, 1)) {
					@include _mlu-check-util-direction($direct, $prop, $value);
				}
			}
		} @else if $bp-name {
			@include mlu-bpm($bp-name) {
				#{$selector}_#{$bp-name} {
					@include mlu-mk-state(&, $states, if($states, 0, 1)) {
						@include _mlu-check-util-direction($direct, $prop, $value);
					}
				}
			}
		} @else {
			#{$selector} {
				@include mlu-mk-state(&, $states, if($states, 0, 1)) {
					@include _mlu-check-util-direction($direct, $prop, $value);
				}
			}
		}
	}
}

@mixin mlu-mk-util-directions($map, $name: null, $prop: null, $bp: null, $states: null) {
	@each $key, $value in $map {
		@if type-of($key) != "string" {
			@error "Invalid key format '#{$key}' for '#{$name}' in map of values";
		}

		$dir: str-slice($key, 1, 1);
		$dir-val: map-get($mlu-main-directions, $dir);
		$util-val: if(not mlu-ston(str-slice($key, 2)), str-slice($key, 3), str-slice($key, 2));
		$tmp-map: ($util-val: $value);

		@if $dir-val {
			@if $name {
				@include mlu-mk-util($name + $dir, $prop + "-" + $dir-val, $tmp-map, $bp, $states, $dir);
			} @else {
				@include mlu-mk-util(to-upper-case($dir), $dir-val, $tmp-map, $bp, $states);
			}
		} @else if $dir == "x" and str-slice($key, 2, 2) == "y" {
			$util-val: if(not mlu-ston(str-slice($key, 3)), str-slice($key, 4), str-slice($key, 3));

			@if $name {
				@include mlu-mk-util($name, $prop, ($util-val: $value), $bp, $states);
			} @else {
				@include mlu-mk-util("mXy", null, ($util-val: $value), $bp, $states, "xy");
			}
		} @else if $dir == "x" or $dir == "y" {
			@if $name {
				@include mlu-mk-util($name + $dir, $prop, $tmp-map, $bp, $states, $dir);
			} @else {
				@include mlu-mk-util("m" + to-upper-case($dir), null, $tmp-map, $bp, $states, $dir);
			}
		} @else {
			@error "Invalid direction '#{$dir}' for '#{$name}' in map of values";
		}
	}
}

@mixin _mlu-check-util-direction($dir, $prop, $value) {
	@if $dir == "x" {
		$prop: if($prop, $prop + "-", "");
		@include _mlu-parse-unit($prop + "right", $value, "r");
		@include _mlu-parse-unit($prop + "left", $value, "l");
	} @else if $dir == "y" {
		$prop: if($prop, $prop + "-", "");
		@include _mlu-parse-unit($prop + "top", $value, "t");
		@include _mlu-parse-unit($prop + "bottom", $value, "b");
	} @else if $dir == "xy" {
		$prop: if($prop, $prop + "-", "");
		@each $item in map-values($mlu-main-directions) {
			@include _mlu-parse-unit($prop + $item, $value, str-slice($item, 1, 1));
		}
	} @else {
		@include _mlu-parse-unit($prop, $value, $dir);
	}
}

@mixin _mlu-parse-unit($prop, $value, $dir) {
	$coef-val: mlu-ston($value + "");
	$dir: if($dir, $dir, "xy");

	@if type-of($value) == "number" and unit($value) == "gg" {
		$tmp-val: if($dir == "t" or $dir == "b", $mlu-gtr-sm-rem, 1);
		$dash-pos: str-index($prop, "-");

		@if $dash-pos and $dir != "xy" {
			$prop: str-slice($prop, 1, $dash-pos - 1);
		} @else if $dir != "xy" {
			$dir: "xy";
		}

		@include mlu-mk-gtr($tmp-val, $type: $prop, $direct: $dir, $coef: $coef-val);
	} @else if type-of($value) == "number" and unit($value) == "su" {
		@if $dir == "xy" {
			@include _mlu-mk-gtr-xy($prop, $mlu-su * $coef-val, $mlu-su-rem * $coef-val);
		} @else {
			$tmp-val: if($dir == "t" or $dir == "b", $mlu-su-rem, $mlu-su);
			#{$prop}: $tmp-val * $coef-val;
		}
	} @else {
		#{$prop}: $value;
	}
}

@mixin mlu-mk-Xy($map, $bp: null, $states: null) {
	@include mlu-mk-util-directions($map, $bp: $bp, $states: $states);
}

@mixin mlu-mk-Maw($map, $bp: null, $states: null) {
	@include mlu-mk-util("Maw", "max-width", $map, $bp, $states);
}

@mixin mlu-mk-Mih($map, $bp: null, $states: null) {
	@include mlu-mk-util("Mih", "min-height", $map, $bp, $states);
}

@mixin mlu-mk-M($map, $bp: null, $states: null) {
	@include mlu-mk-util-directions($map, "M", "margin", $bp, $states);
}

@mixin mlu-mk-P($map, $bp: null, $states: null) {
	@include mlu-mk-util-directions($map, "P", "padding", $bp, $states);
}

@mixin mlu-mk-C($map, $bp: null, $states: null) {
	@include mlu-mk-util("C", "color", $map, $bp, $states);
}

@mixin mlu-mk-Lh($map, $bp: null, $states: null) {
	@include mlu-mk-util("Lh", "line-height", $map, $bp, $states);
}

@mixin mlu-mk-Fw($map, $bp: null, $states: null) {
	@include mlu-mk-util("Fw", "font-weight", $map, $bp, $states);
}

@mixin mlu-mk-Fz($map, $bp: null, $states: null) {
	@include mlu-mk-util("Fz", "font-size", $map, $bp, $states);
}

@mixin mlu-mk-Ff($map, $bp: null, $states: null) {
	@include mlu-mk-util("Ff", "font-family", $map, $bp, $states);
}

@mixin mlu-mk-Bgc($map, $bp: null, $states: null) {
	@include mlu-mk-util("Bgc", "background-color", $map, $bp, $states);
}

@mixin mlu-mk-Bdxy($map, $bp: null, $states: null) {
	@include mlu-mk-util-directions($map, "Bd", "border", $bp, $states);
}

@mixin mlu-mk-Bdc($map, $bp: null, $states: null) {
	@include mlu-mk-util("Bdc", "border-color", $map, $bp, $states);
}

@mixin mlu-mk-Bdw($map, $bp: null, $states: null) {
	@include mlu-mk-util("Bdw", "border-width", $map, $bp, $states);
}

@mixin mlu-mk-Bdrs($map, $bp: null, $states: null) {
	@include mlu-mk-util("Bdrs", "border-radius", $map, $bp, $states);
}

@mixin mlu-mk-Bxsh($map, $bp: null, $states: null) {
	@include mlu-mk-util($map, "Bxsh", "box-shadow", $bp, $states);
}

@mixin mlu-mk-Trf($map, $bp: null, $states: null) {
	@include mlu-mk-util("Trf", "transform", $map, $bp, $states);
}

@mixin mlu-mk-O($map, $bp: null, $states: null) {
	@include mlu-mk-util("O", "opacity", $map, $bp, $states);
}

@use 'sass-true' as *;
@use 'tools' as mlu;
@use 'sass:map';

$this: 'D';

mlu.$utils-config: map.set(
	mlu.$utils-config, 'states', 'keywords', 'st1', ('iv' 'vl')
);

@include describe('tools/mixins/utils') {
	@include describe('mk-state') {
		@include it('make only post states') {
			@include assert() {
				@include output(false) {
					.D-f {
						@include mlu.new-mk-state('h:af,!a:af', null, false) {
							display: flex;
						}
					}
				}

				@include expect(false) {
					.D-f_h\:af\,\!a\:af:hover::after,
					.D-f_h\:af\,\!a\:af:not(:active)::after {
						display: flex;
					}
				}
			}

			@include assert() {
				@include output(false) {
					.D-f {
						@include mlu.new-mk-state('&-,&-:f', null, null, &, $this) {
							display: flex;
						}
					}
				}

				@include expect(false) {
					.D-f_\&-\,\&-\:f.D-f_\&-\,\&-\:f,
					.D-f_\&-\,\&-\:f.D-f_\&-\,\&-\:f:focus {
						display: flex;
					}
				}
			}

			@include assert() {
				@include output(false) {
					.D-f {
						@include mlu.new-mk-state('::^one:fw:=+*', null) {
							display: flex;
						}
					}
				}

				@include expect(false) {
					.D-f {
						display: flex;
					}

					.D-f_\:\:\^one\:fw\:\=\+\* .-Ctx-one:focus-within+* {
						display: flex;
					}
				}
			}

			@include assert() {
				@include output(false) {
					.D-f {
						@include mlu.new-mk-state('h,f ' + mlu.$states-ps, null, false) {
							display: flex;
						}
					}
				}

				@include expect(false) {
					.D-f_h\,f:hover,
					.D-f_h\,f:focus {
						display: flex;
					}

					@each $key, $value in map.get(mlu.$utils-config, 'states', 'pseudo') {
						.D-f_#{$key + $value} {
							display: flex;
						}
					}
				}
			}

			@include assert() {
				@include output(false) {
					.D-f {
						@include mlu.new-mk-state(':^:' + mlu.$states-ps, null, null) {
							display: flex;
						}
					}
				}

				@include expect(false) {
					@each $key, $value in map.get(mlu.$utils-config, 'states', 'pseudo') {
						.D-f_\:\^\:#{$key} .-Ctx#{$value} {
							display: flex;
						}
					}
				}
			}

			@include assert() {
				@include output(false) {
					.D-f {
						@include mlu.new-mk-state('h:' + 'st1', null, null) {
							display: flex;
						}
					}
				}

				@include expect(false) {
					@each $item in map.get(mlu.$utils-config, 'states', 'keywords', 'st1') {
						.D-f_h\:#{$item + ':hover' + map.get(mlu.$utils-states, $item)} {
							display: flex;
						}
					}
				}
			}
		}

		@include it('make only pre states') {
			@include assert() {
				@include output(false) {
					.D-f {
						@include mlu.new-mk-state(null, '^:h', false) {
							display: flex;
						}
					}
				}

				@include expect(false) {
					.-Ctx:hover .\^\:h_D-f {
						display: flex;
					}
				}
			}

			@include assert() {
				@include output(false) {
					.D-f {
						@include mlu.new-mk-state(null, '=a:^:h,&:^1:+', false, &, $this) {
							display: flex;
						}
					}
				}

				@include expect(false) {
					a.-Ctx:hover .\=a\:\^\:h\,\&\:\^1\:\+_D-f,
					.D.-Ctx1+ .\=a\:\^\:h\,\&\:\^1\:\+_D-f {
						display: flex;
					}
				}
			}

			@include assert() {
				@include output(false) {
					.D-f {
						@include mlu.new-mk-state(null, '=h2. =ul:h', false) {
							display: flex;
						}
					}
				}

				@include expect(false) {
					h2.\=h2\._D-f {
						display: flex;
					}

					ul:hover .\=ul\:h_D-f {
						display: flex;
					}
				}
			}

			@include assert() {
				@include output(false) {
					.D-f {
						@include mlu.new-mk-state(null, '^ct1:' + mlu.$states-ps, false) {
							display: flex;
						}
					}
				}

				@include expect(false) {
					@each $key, $value in map.get(mlu.$utils-config, 'states', 'pseudo') {
						.-Ctx-ct1#{$value} .\^ct1\:#{$key}_D-f {
							display: flex;
						}
					}
				}
			}
		}

		@include it('make pre and post states without no-state rule') {
			@include assert() {
				@include output(false) {
					.D-f {
						@include mlu.new-mk-state('&-ib:af', '^one:h', false, &, $this) {
							display: flex;
						}
					}
				}

				@include expect(false) {
					.-Ctx-one:hover .\^one\:h_D-f {
						display: flex;
					}

					.D-f_\&-ib\:af.D-ib::after {
						display: flex;
					}
				}
			}

			@include assert() {
				@include output(false) {
					.D-f {
						@include mlu.new-mk-state(
							mlu.$states-cmb + ' af',
							mlu.$states-cmb + ' ^one:h',
							false,
						) {
							display: flex;
						}
					}
				}

				@include expect(false) {
					.-Ctx-one:hover .\^one\:h_D-f_af::after {
						display: flex;
					}
				}
			}

			@include assert() {
				@include output(false) {
					.D-f {
						@include mlu.new-mk-state(
							'&:af #{mlu.$states-cmb} af',
							'^one:h #{mlu.$states-cmb} ^:f',
							false,
							&,
							$this
						) {
							display: flex;
						}
					}
				}

				@include expect(false) {
					.-Ctx-one:hover .\^one\:h_D-f {
						display: flex;
					}

					.D-f_\&\:af.D::after {
						display: flex;
					}

					.-Ctx:focus .\^\:f_D-f_af::after {
						display: flex;
					}
				}
			}

			@include assert() {
				@include output(false) {
					.D-f {
						@include mlu.new-mk-state(
							'&:af #{mlu.$states-cmb} af',
							'^one:h ^:f',
							false,
							&,
							$this
						) {
							display: flex;
						}
					}
				}

				@include expect(false) {
					.-Ctx-one:hover .\^one\:h_D-f {
						display: flex;
					}

					.-Ctx:focus .\^\:f_D-f {
						display: flex;
					}

					.D-f_\&\:af.D::after {
						display: flex;
					}
				}
			}

			@include assert() {
				@include output(false) {
					.D-f {
						@include mlu.new-mk-state(
							'&:af af',
							'^one:h #{mlu.$states-cmb} ^:f',
							false,
							&,
							$this
						) {
							display: flex;
						}
					}
				}

				@include expect(false) {
					.-Ctx-one:hover .\^one\:h_D-f {
						display: flex;
					}

					.D-f_\&\:af.D::after {
						display: flex;
					}

					.D-f_af::after {
						display: flex;
					}
				}
			}

			@include assert() {
				@include output(false) {
					.D-f {
						@include mlu.new-mk-state(
							mlu.$states-cmb + ' fw:af,a:af',
							mlu.$states-cmb + ' ^1:f,^2:>',
							false,
						) {
							display: flex;
						}
					}
				}

				@include expect(false) {
					.-Ctx1:focus .\^1\:f\,\^2\:\>_D-f_fw\:af\,a\:af:focus-within::after,
					.-Ctx1:focus .\^1\:f\,\^2\:\>_D-f_fw\:af\,a\:af:active::after,
					.-Ctx2> .\^1\:f\,\^2\:\>_D-f_fw\:af\,a\:af:focus-within::after,
					.-Ctx2> .\^1\:f\,\^2\:\>_D-f_fw\:af\,a\:af:active::after {
						display: flex;
					}
				}
			}

			@include assert() {
				@include output(false) {
					.D-f {
						@include mlu.new-mk-state(
							mlu.$states-cmb + 'af,bf a:af',
							mlu.$states-cmb + ':h =a:a:>,=a.act:>',
							false,
						) {
							display: flex;
						}
					}
				}

				@include expect(false) {
					:hover .\:h_D-f_af\,bf::after,
					:hover .\:h_D-f_af\,bf::before {
						display: flex;
					}

					:hover .\:h_D-f_a\:af:active::after {
						display: flex;
					}

					a:active> .\=a\:a\:\>\,\=a\.act\:\>_D-f_af\,bf::after,
					a:active> .\=a\:a\:\>\,\=a\.act\:\>_D-f_af\,bf::before,
					a.act> .\=a\:a\:\>\,\=a\.act\:\>_D-f_af\,bf::after,
					a.act> .\=a\:a\:\>\,\=a\.act\:\>_D-f_af\,bf::before {
						display: flex;
					}

					a:active> .\=a\:a\:\>\,\=a\.act\:\>_D-f_a\:af:active::after,
					a.act> .\=a\:a\:\>\,\=a\.act\:\>_D-f_a\:af:active::after {
						display: flex;
					}
				}
			}
		}

		@include it('make pre and post states and no-state rule') {
			@include assert() {
				@include output(false) {
					.D-f {
						@include mlu.new-mk-state(null, '^:f', true) {
							display: flex;
						}
					}
				}

				@include expect(false) {
					.D-f {
						display: flex;
					}

					.-Ctx:focus .\^\:f_D-f {
						display: flex;
					}
				}
			}

			@include assert() {
				@include output(false) {
					.D-f {
							@include mlu.new-mk-state('f:af') {
								display: flex;
						}
					}
				}

				@include expect(false) {
					.D-f {
						display: flex;
					}

					.D-f_f\:af:focus::after {
						display: flex;
					}
				}
			}

			@include assert() {
				@include output(false) {
					.D-f {
						@include mlu.new-mk-state(null) {
							display: flex;
						}
					}
				}

				@include expect(false) {
					.D-f {
						display: flex;
					}
				}
			}

			@include assert() {
				@include output(false) {
					.D-f {
						@include mlu.new-mk-state('h:af', '^act') {
							display: flex;
						}
					}
				}

				@include expect(false) {
					.D-f {
						display: flex;
					}

					.-Ctx-act .\^act_D-f {
						display: flex;
					}

					.D-f_h\:af:hover::after {
						display: flex;
					}
				}
			}

			@include assert() {
				@include output(false) {
					@include mlu.new-mk-state('af', '&:h', true, '.D-ib', $this) {
						display: inline-block;
					}
				}

				@include expect(false) {
					.D-ib {
						display: inline-block;
					}

					.D:hover .\&\:h_D-ib {
						display: inline-block;
					}

					.D-ib_af::after {
						display: inline-block;
					}
				}
			}

		}

		@include it('make states with custom tokens') {
			mlu.$tUSv: '~';
			mlu.$tUNv: '~';
			mlu.$tUCm: '__';
			mlu.$tSOr: '|';
			mlu.$tSAnd: '&';
			mlu.$tSCs: '#';
			mlu.$tSCn: '%';
			mlu.$tSRaw: '?';
			mlu.$tSTu: '$';
			mlu.$tSNot: '*';
			mlu.$tSTucv: mlu.$tSTu + mlu.$tUSv;

			@include assert() {
				@include output(false) {
					.xs\:md__D-f {
						@include mlu.new-mk-state(
							'$~ $~ib&#testou&af',
							'%one&*a|%&?>*',
							false,
							&,
							$this
						) {
							display: flex;
						}
					}
				}

				@include expect(false) {
					.-Ctx\~one:not(:active) .xs\:md__\%one\&\*a\|\%\&\?\>\*__D-f,
					.-Ctx>* .xs\:md__\%one\&\*a\|\%\&\?\>\*__D-f {
						display: flex;
					}

					.xs\:md__D-f__\$\~.xs\:md__D-f__\$\~ {
							display: flex;
					}

					.xs\:md__D-f__\$\~ib\&\#testou\&af.D\~ib.pa.ro.voz::after {
						display: flex;
					}
				}
			}

			mlu.$tUSv: map.get(mlu.$utils-config, 'tokens', 'util', 'str-value');
			mlu.$tUNv: map.get(mlu.$utils-config, 'tokens', 'util', 'num-value');
			mlu.$tUCm: map.get(mlu.$utils-config, 'tokens', 'util', 'component');
			mlu.$tSOr: map.get(mlu.$utils-config, 'tokens', 'states', 'or');
			mlu.$tSAnd: map.get(mlu.$utils-config, 'tokens', 'states', 'and');
			mlu.$tSNot: map.get(mlu.$utils-config, 'tokens', 'states', 'not');
			mlu.$tSCs: map.get(mlu.$utils-config, 'tokens', 'states', 'custom');
			mlu.$tSTu: map.get(mlu.$utils-config, 'tokens', 'states', 'this-util');
			mlu.$tSCn: map.get(mlu.$utils-config, 'tokens', 'states', 'context');
			mlu.$tSRaw: map.get(mlu.$utils-config, 'tokens', 'states', 'raw');
			mlu.$tSTucv: mlu.$tSTu + mlu.$tUSv;
		}
	}
}
